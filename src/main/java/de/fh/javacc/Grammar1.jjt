// @author https://stackoverflow.com/a/13921386
// TestParser.jjt
options {
    VISITOR = true;
    MULTI = true;
    IGNORE_CASE = false;
}

PARSER_BEGIN(TestParser)
package de.fh.javacc.generated;
public class TestParser {
  public static SimpleNode parse(java.io.InputStream is) throws ParseException {
      TestParser parser = new TestParser(is);
      return parser.compilationUnit(); // SimpleNode root = parser.program()
  }
}

PARSER_END(TestParser)

TOKEN : {
//  <TypeChar: "char" > |
//  <TypeInt: "int"> |
//  <TypeString: "String" > |
//  <TypeBoolean: "boolean" > |
//  <TypePath:  "Path"> |
//  <TypeFiles: "Files" >|
  <TypeMap: "Map">
  |<TypeSet: "Set">
  |<TypeSpecifiers: "int" | "char" | "String" | "boolean" | "Path"|  "Files" >
  |<LBRACKET : "[">|
   <RBRACKET : "]">
  |";" | "{" | "}" | "," // TODO introduce name
  | <TypeVoid: "void">
  | <While: "while">
  | <For: "for">
  | <SimpleEquals: "="| "+=" |"-=" |"*="| "/=" | "%=" >
  | <Point: ".">
  | <RoundBracketOpen: "(">
  | <RoundBracketClose: ")">
  | <BooleanLiteral: "true" | "false" >
  | <LessThan: "<">
  | <GreaterThan: ">">
  | <BinVergleich : ">="  | "<=" | "==" | "!=" >
  | <BinJunktor : "||" | "&&" >
  | <OpSum : "+" | "-">
  | <OpUnaer: "!">
  | <OpIncrement: "++" | "--">
  | <OpProd : "*" | "/" | "%">
  | <Identifier : ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])* >
  | <IntegerLiteral : "0" | (["1"-"9"] (["0"-"9"])*) >
  | <DoubleLiteral : <IntegerLiteral> <Point> (["0"-"9"])* | <Point> (["0"-"9"])+ >
  | <StringLiteral: "\""(["A"-"Z", "a"-"z", "_", "0" - "9", " "])*"\"" > //ToDO vervollständigen
  | <CharLiteral:"\""(["A"-"Z", "a"-"z", "_", "0" - "9", " "])"\"" >//ToDO vervollständigen
  | <PathLiteral:  "/" ["A"-"Z", "a"-"z", "_", "0" - "9"](["A"-"Z", "a"-"z", "_", "0" - "9"])*("/"["A"-"Z", "a"-"z", "_", "0" - "9"](["A"-"Z", "a"-"z", "_", "0" - "9"])*)* >


}


SKIP : {   " " | "\t" | "\n" | "\r" | <Kommentar: "//" (~["\n"])* >
}

// TODO check operator precedence https://www.javatpoint.com/java-operator-precedence
SimpleNode compilationUnit() #PROGRAM :
{
    boolean first = true;
    SimpleNode result = null; // Initialize the result
} {(
       (LOOKAHEAD(2) stmnt() | decl() | (methodOrVariableCaller() ";")) { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); }
    )*
    { return result; } // Return the result
}
void methodOrVariableCaller() #REQUESTER_VAR_METHOD :
{
 Token t;
} {
  t = <Identifier> methodOrVariableCalled()
  {
  jjtThis.value = t.image;
  }
}
void methodOrVariableCalled() #GET_VAR_METHOD :
{
 Token t;

} {
  <Point> t = <Identifier> [methodCallParams()] [methodOrVariableCalled()]
  {
  jjtThis.value = t.image;
  }
 }


void methodCallParams() #GET_METHOD_PARAMS :
{}
{
    <RoundBracketOpen> [junktoren() #PARAM(true) ("," junktoren() #PARAM)*] <RoundBracketClose>
}

void stmnt() #STATEMENT :
{
  Token end;
} {
  block() | whileStmnt()  | forStmnt() | ausdruck() end = ";"
}


void decl() #DECL :
{} {

 type() identifier() decide_declaration_type() |


 <TypeVoid> identifier() method_declaration()

}




void decide_declaration_type() #void :
{}
{
    ([variable_declaration()] ";") | method_declaration()
}










void method_declaration() #METHDECL :
{} {
 params() block()
}

void params() #void :
{} {
   <RoundBracketOpen> [param_pair() ("," param_pair())*] <RoundBracketClose>
}

void param_pair() #PARAM_PAIR :
{}
{
    type() identifier()
}

void type() #TYPE :
{
  Token t;
}
{
  (        t =<TypeSpecifiers> | t = <TypeSet> Set() | t = <TypeMap> Map())


  {
      jjtThis.value = t.image;
  }
}

void Set() #KOMPLEX_TYPE :
{}
{
  <LessThan> type() <GreaterThan>
}
void Map() #KOMPLEX_TYPE :
{}
{
   <LessThan> type() "," type() <GreaterThan>
}

void identifier() #VAR_METHOD_NAME :
{
  Token t;
}
{
  t=<Identifier>
  {
    jjtThis.value = t.image;
  }
}

void block() #BLOCK :
{
    Token start, end;
} {
   start = "{" (
         (stmnt() | decl())
       )*
   end = "}"
}

void whileStmnt() #WHILE :
{
   Token start;
} {
  start = <While> <RoundBracketOpen> ausdruck() #CONDITION <RoundBracketClose> stmnt()
}

void forStmnt() #For :
{
   Token start;
} {
  start = <For> <RoundBracketOpen> forinit() ";" forcond() ";" foroper() <RoundBracketClose> stmnt()



}



void forinit() #For :
{
   Token start;
} {

    identifier()

}

void forcond() #For :
{
   Token start;
} {

 identifier()

}

void foroper() #For :
{
   Token start;
} {

 identifier()

}
void array()  #ATOM_Array:
{

}
{
<LBRACKET> ArrayElement() ("," ArrayElement())* <RBRACKET>   {}
}

void ArrayElement() #void:
{
Token inc=null;
Token ident = null;
}
{
    array()  | ident=<Identifier> {jjtThis.value = ident.image; } #ATOM_VARIABLE
             | ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
             | ident=<DoubleLiteral> {jjtThis.value = ident.image; } #ATOM_DBL
             | ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
             |ident = <StringLiteral> {jjtThis.value = ident.image; } #ATOM_String
             | <RoundBracketOpen> junktoren() <RoundBracketClose>
               }






// TODO = += -= *= /= %= hinzufügen
void variable_declaration() #VARIABLE_ASSIGNMENT_PRIO_1 :
{Token t;} {
 t = <SimpleEquals> {jjtThis.value = t.image;} ausdruck()
}

void ausdruck() #void :
{
   Token ident;
} {
    LOOKAHEAD(2)
  (ident=<Identifier> {jjtThis.value = ident.image; } variable_declaration()) #VAR_METHOD_NAME
  | junktoren()
}


void junktoren() #void :
{} {
   vergleich() (junktoren2())*
}

// TODO OPERATION PRIO 4 &&     und OPERATION PRIO 3 || aufsplitten
void junktoren2() #OPERATION_PRIO_4_AND_3 :
{ Token t; }
{
    t=<BinJunktor> {jjtThis.value = t.image;} vergleich()
}

void vergleich() #void :
{} {
   summe() (vergleich2())*
}

// TODO OPERATION PRIO 8 == !=

// < <= > >=
void vergleich2() #OPERATION_PRIO_9 :
{Token op;}
{
    (op=<BinVergleich> | op = <LessThan> | op = <GreaterThan>) {jjtThis.value = op.image;} summe()
}

void summe() #void :
{} {
    produkt() (summe2())*
}

// + -
void summe2() #OPERATION_PRIO_11 :
{Token op;}
{
    op=<OpSum> {jjtThis.value = op.image;} produkt()
}

void produkt() #void :
{} {
    unaer_pre() (produkt2())*
}

// * / %
void produkt2() #OPERATION_PRIO_12 :
{Token op;}
{
    op=<OpProd> {jjtThis.value = op.image;} unaer_pre()
}

void unaer_pre() #void :
{} {
  unaer_pre2() | unaer_post()
}

// ++ -- (pre) + - ! ~ (type)
void unaer_pre2() #OPERATION_PRIO_13 :
{ Token op; }
{
    (op = <OpSum> | op = <OpUnaer> | op = <OpIncrement>) {jjtThis.value = op.image;} atom()
    // Nach Java IDE darf kein Post-Increment mehr kommen, wenn ein pre Increment vorliegt, weshalb direkt zum atom geskippt wird
}

void unaer_post() #void :
{}
{
    LOOKAHEAD(atom() <OpIncrement>)
    unaer_post2() | atom()
}

// ++ -- (post)
void unaer_post2() #OPERATION_PRIO_14 :
{ Token inc; }
{
    atom() inc=<OpIncrement> {jjtThis.value = inc.image; }
}

// OPERATION_PRIO_15 () [] . (Parentheses, Array subscript, Member selection)
void atom() #void :
{
    Token ident = null;
    Token inc=null;
} {
    LOOKAHEAD(2)
  methodOrVariableCaller()
  | ident=<Identifier> {jjtThis.value = ident.image; } #ATOM_VARIABLE
  | ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
  | ident=<DoubleLiteral> {jjtThis.value = ident.image; } #ATOM_DBL
  | ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
  | array()
  |ident = <StringLiteral> {jjtThis.value = ident.image; } #ATOM_String
  | <RoundBracketOpen> junktoren() <RoundBracketClose>
}
