options {
    VISITOR = true;
    MULTI = true;
    IGNORE_CASE = false;
}

PARSER_BEGIN(TestParser)
package de.fh.javacc.generated;
public class TestParser {
  public static SimpleNode parse(java.io.InputStream is) throws ParseException {
      TestParser parser = new TestParser(is);
      return parser.compilationUnit(); // SimpleNode root = parser.program()
  }
}

PARSER_END(TestParser)

TOKEN : {

  <TypeMap: "Map">
  |<TypeSet: "Set">
  |<TypeSpecifiers: "int" | "char" | "String" | "boolean"| "Files" >
  |<LBRACKET : "[">|
   <RBRACKET : "]">
   |<TypePath: "Path" >

   | <IF: "if">
   | <ELSE: "else">
  |";" |  ","
  | <GBracketOpen: "{">
  | <GBracketClose: "}">
  | <TypeVoid: "void">
  | <While: "while">
  | <For: "for">
  | <SimpleEquals: "="| "+=" |"-=" |"*="| "/=" | "%=" >
  | <Point: ".">
  | <RoundBracketOpen: "(">
  | <RoundBracketClose: ")">
  | <BooleanLiteral: "true" | "false" >
  | <LessThan: "<">
  | <GreaterThan: ">">
  | <BinVergleich : ">="  | "<=" | "==" | "!=" >
  | <BinJunktor : "||" | "&&" >
  | <OpSum : "+" | "-" | "^" >
  | <OpUnaer: "!">
  | <OpIncrement: "++" | "--">
  | <OpProd : "*" | "%">
  | <FWD: "/">
  | <Return : "return">
  | <Identifier : ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])* >
  | <IntegerLiteral : "0" | (["1"-"9"] (["0"-"9"])*) >
  | <StringLiteral: "\""(~["\"","\n"])*"\"" >
  | <CharLiteral:"'"(["'","\n"])"'" >
  |<PathLiteral:".."|  ["A"-"Z"]":">


}


SKIP : {   " " | "\t" | "\n" | "\r" | <Kommentar: "//" (~["\n"])* |  "/*" ( ~["*"] | "*" ~["/"] )* "*/" >
}

// TODO check operator precedence https://www.javatpoint.com/java-operator-precedence
SimpleNode compilationUnit() #PROGRAM :
{
    boolean first = true;
    SimpleNode result = null; // Initialize the result
} {(
       (LOOKAHEAD(2) stmnt() | decl() | (methodOrVariableCaller() ";")) { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); }
    )*
    { return result; } // Return the result
}
void methodOrVariableCaller() #REQUESTER_VAR_METHOD :
{
 Token t;
} {


   t = <Identifier> [methodCallParams()](Arrayaufruf())* [methodOrVariableCalled()]

    { jjtThis.value = t.image; }
}

void Arrayaufruf() #ARRAYAUFRUF :
{Token t;}
{
    "[" ausdruck() "]"
}






void methodOrVariableCalled() #GET_VAR_METHOD :
{
Token t;

} {
  t = <Point>  methodOrVariableCaller()
{jjtThis.value = t.image;}
 }


void methodCallParams() #GET_METHOD_PARAMS :
{}
{
    <RoundBracketOpen> [junktoren() #PARAM(true) ("," junktoren() #PARAM)*] <RoundBracketClose>
}

void stmnt() #STATEMENT :
{}
{
LOOKAHEAD(3)
  block() | whileStmnt() | ifstmt() | forStmnt() | (ausdruck() ";")
}


void decl() #DECL :
{} {
 typePath() identifier() decide_declaration_typePath() |
 type() identifier() decide_declaration_type() |
 type_void() identifier() method_declaration()
}

void type_void() #TYPE :
{Token t;}
{
    t = <TypeVoid> {jjtThis.value = t;}
}

void decide_declaration_type() #void :
{}
{
    ([variable_declaration()] ";") #CONCLUDED_VAR_DEC | method_declaration()
}
void decide_declaration_typePath() #void :
{}
{
    ([<SimpleEquals> Path() #ATOM_PATH] ";") #CONCLUDED_VAR_DEC | method_declaration()
}
void method_declaration() #METHDECL :
{} {
 params() block()
}

void params() #DECL_METHOD_PARAMS :
{} {
   <RoundBracketOpen> [param_pair() ("," param_pair())*] <RoundBracketClose>
}

void param_pair() #PARAM_PAIR :
{}
{
    type() identifier()
}

void type() #TYPE :
{
  Token t;
}
{
  (        t =<TypeSpecifiers> | t = <TypeSet> Set() | t = <TypeMap> Map())


  {
      jjtThis.value = t.image;
  }
}

void typePath() #TYPE :
{
  Token t;
}
{
  t = <TypePath>


  {
      jjtThis.value = t.image;
  }

}


void Set() #KOMPLEX_TYPE :
{}
{
  <LessThan> type() <GreaterThan>
}
void Map() #KOMPLEX_TYPE :
{}
{
   <LessThan> type() "," type() <GreaterThan>
}

void identifier() #VAR_METHOD_NAME :
{
  Token t;
}
{
  t=<Identifier>
  {
    jjtThis.value = t.image;
  }
}

void block() #BLOCK :
{

} {
   <GBracketOpen> (
         (( <Return>  [ausdruck()] ";")#RETURN |stmnt() | decl()  )
       )*

   <GBracketClose>
}

void whileStmnt() #WHILE :
{
   Token start;
} {
  start = <While> <RoundBracketOpen> ausdruck() #CONDITION <RoundBracketClose> stmnt()
}

void forStmnt() #For :
{
   Token start;
} {
  start = <For> <RoundBracketOpen> forinit() (";" forcond() ";" foroper()| ":" identifier() #FOREACH) <RoundBracketClose> stmnt()




}


void ifstmt() #IF :
{
   Token start;
} {
  start = <IF> <RoundBracketOpen> ausdruck() #CONDITION <RoundBracketClose> stmnt() elsestmt()
}

void elsestmt() #ELSE :
{
   Token start;
} {
  start = <ELSE>  stmnt()
}
void forinit() #FORINIT :
{
   Token start;
} {

   [type() identifier() [variable_declaration()] |ausdruck() ]

}

void forcond() #FORCOND :
{
   Token start;
} {

 [ausdruck() ]

}

void foroper() #FOROPER :
{
   Token start;
} {

 [ausdruck() ]

}
void array()  #ATOM_ARRAY:
{}
{
<LBRACKET> array_element() ("," array_element())* <RBRACKET>
}
void array_element() #ARRAY_ELEMENT:
{}
{
    ausdruck()
}
void atomset()  #ATOM_SET:
{}
{
<GBracketOpen> set_element() ("," set_element())* <GBracketClose>
}

void atommap()  #ATOM_MAP:
{}
{
<LBRACKET> map_element() ("," map_element())* <RBRACKET>
}




void Path()  #ATOM_PATHELEMENT:
{Token t;
 }

{

     (t = <PathLiteral> | t = <Point> | t = <Identifier> )[("/" | "\\") [Path()]]
{jjtThis.value = t.image;}
}

void map_element() #MAP_PAIR:
{}
{
    atom() #MAP_KEY ":" atom() #MAP_VALUE
}


void set_element() #SET_ELEMENT:
{}
{
    ausdruck()
}

// TODO = += -= *= /= %= hinzuf√ºgen
void variable_declaration() #VARIABLE_ASSIGNMENT_PRIO_1 :
{Token t;} {
 t = <SimpleEquals> {jjtThis.value = t.image;} ausdruck()
}

void ausdruck() #void :
{
   Token ident;
} {
    LOOKAHEAD(2)
  (ident=<Identifier> {jjtThis.value = ident.image; } variable_declaration()) #VAR_METHOD_NAME
  | junktoren()
}


void junktoren() #void :
{} {
   vergleich() (junktoren2())*
}

// TODO OPERATION PRIO 4 &&     und OPERATION PRIO 3 || aufsplitten
void junktoren2() #OPERATION_PRIO_4_AND_3 :
{ Token t; }
{
    t=<BinJunktor> {jjtThis.value = t.image;} vergleich()
}

void vergleich() #void :
{} {
   summe() (vergleich2())*
}

// TODO OPERATION PRIO 8 == !=

// < <= > >=
void vergleich2() #OPERATION_PRIO_9 :
{Token op;}
{
    (op=<BinVergleich> | op = <LessThan> | op = <GreaterThan>) {jjtThis.value = op.image;} summe()
}

void summe() #void :
{} {
    produkt() (summe2())*
}

// + -
void summe2() #OPERATION_PRIO_11 :
{Token op;}
{
    op=<OpSum> {jjtThis.value = op.image;} produkt()
}

void produkt() #void :
{} {
    unaer_pre() (produkt2())*
}

// * / %
void produkt2() #OPERATION_PRIO_12 :
{Token op;}
{
    op=<FWD> {jjtThis.value = op.image;} unaer_pre()|
    op=<OpProd> {jjtThis.value = op.image;} unaer_pre()
}

void unaer_pre() #void :
{} {
  unaer_pre2() | unaer_post()
}

// ++ -- (pre) + - ! ~ (type)
void unaer_pre2() #OPERATION_PRIO_13 :
{ Token op; }
{
    (op = <OpSum> | op = <OpUnaer> | op = <OpIncrement>) {jjtThis.value = op.image;} atom()
    // Nach Java IDE darf kein Post-Increment mehr kommen, wenn ein pre Increment vorliegt, weshalb direkt zum atom geskippt wird
}

void unaer_post() #void :
{}
{
    LOOKAHEAD(atom() <OpIncrement>)
    unaer_post2() | atom()
}

// ++ -- (post)
void unaer_post2() #OPERATION_PRIO_14 :
{ Token inc; }
{
    atom() inc=<OpIncrement> {jjtThis.value = inc.image; }
}


void atom() #void :
{
    Token ident = null;
    Token inc=null;
} {
    LOOKAHEAD(2)
  methodOrVariableCaller()
  | ident=<Identifier> {jjtThis.value = ident.image; } #ATOM_VARIABLE
  | ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
  | ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
  | ident = <StringLiteral> {jjtThis.value = ident.image; } #ATOM_STRING
  | ident = <CharLiteral> {jjtThis.value = ident.image; } #ATOM_CHAR
  | (LOOKAHEAD(3) array()| atomset()| atommap())

  | <RoundBracketOpen> junktoren() <RoundBracketClose>
}
