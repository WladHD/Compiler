// @author https://stackoverflow.com/a/13921386
// TestParser.jjt
options {
    VISITOR = true;
    MULTI = true;
    IGNORE_CASE = false;
}

PARSER_BEGIN(TestParser)
package de.fh.javacc.generated;
public class TestParser {
  public static SimpleNode parse(java.io.InputStream is) throws ParseException {
      TestParser parser = new TestParser(is);
      return parser.compilationUnit(); // SimpleNode root = parser.program()
  }
}

PARSER_END(TestParser)

TOKEN : {
  <TypeSpecifiers: "int"| "char" | "String" | "boolean"| "Path"|  "Files" >
  | <MethodSpecifiers: <TypeSpecifiers> | "void">
  | "while" | ";" | "=" | "{" | "}" | "," | "Map" | "Set" // TODO introduce name
  | <Point: ".">
  | <RoundBracketOpen: "(">
  | <RoundBracketClose: ")">
  | <BooleanLiteral: "true" | "false" >
  | <LessThan: "<">
  | <GreaterThan: ">">
  | <BinVergleich : ">="  | "<=" | "==" | "!=" >
  | <BinJunktor : "||" | "&&" >
  | <OpSum : "+" | "-">
  | <OpUnaer: "!">
  | <OpIncrement: "++" | "--">
  | <OpProd : "*" | "/" | "%">
  | <Identifier : ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])* >
  | <IntegerLiteral : "0" | (["1"-"9"] (["0"-"9"])*) >
  | <DoubleLiteral : <IntegerLiteral> <Point> (["0"-"9"])* | <Point> (["0"-"9"])+ >
  | <StringLiteral: "\""(["A"-"Z", "a"-"z", "_", "0" - "9"])*"\"" > //ToDO vervollständigen
  | <CharLiteral:"\""(["A"-"Z", "a"-"z", "_", "0" - "9"])"\"" >//ToDO vervollständigen
}



SKIP : {   " " | "\t" | "\n" | "\r" | <Kommentar: "//" (~["\n"])* >
}

// TODO check operator precedence https://www.javatpoint.com/java-operator-precedence
SimpleNode compilationUnit() #PROGRAM :
{
    boolean first = true;
    SimpleNode result = null; // Initialize the result
} {(
       (LOOKAHEAD(2) stmnt() | decl() | methodOrVariableCaller()) { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); }
    )*
    { return result; } // Return the result
}
void methodOrVariableCaller() #CALLER :
{
 Token t;
} {
  t = <Identifier> methodOrVariableCalled()
  {
  jjtThis.value = t.image;
  }
}
void methodOrVariableCalled() #CALL_TO :
{
 Token t;

} {
  <Point> t = <Identifier> [methodCallParams()] (methodOrVariableCalled() | ";")
  {
  jjtThis.value = t.image;
  }
 }

void methodCallParams() #CALL_METHOD_PARAMS :
{}
{
    <RoundBracketOpen> [junktoren() #PARAM(true) ("," junktoren() #PARAM)*] <RoundBracketClose>
}

void stmnt() #STMT :
{
  Token end;
} {
  block() | whileStmnt()  | ausdruck() end = ";"
}


void decl() #DECL :
{} {
 (type() identifier() Vardecl()) |
 (Methtype() identifier() Methdecl())
}


void Vardecl() #void :
{} {
 ["=" ausdruck() #VARDECL]";"
}
void Methdecl() #METHDECL :
{} {
 params() block()
}

void params() #void :
{} {
   <RoundBracketOpen> [param_pair() ("," param_pair())*] <RoundBracketClose>
}

void param_pair() #PARAM_PAIR :
{}
{
    type() identifier()
}

void Methtype() #TYPE :
{
  Token t;
}
{
  (t = <MethodSpecifiers> )
  {
      jjtThis.value = t.image;
  }
}

void type() #TYPE :
{
  Token t;
}
{
  (t = <TypeSpecifiers> | t = "Set" Set() | t = "Map" Map())
  {
      jjtThis.value = t.image;
  }
}

void Set() #Set :
{}
{
  <LessThan> type() <GreaterThan>
}
void Map() #Map :
{}
{
   <LessThan> type() "," type() <GreaterThan>
}

void identifier() #IDENTIFIER :
{
  Token t;
}
{
  t=<Identifier>
  {
    jjtThis.value = t.image;
  }
}

void block() #BLOCK :
{
    Token start, end;
} {
   start = "{" (
         (stmnt() | decl())
       )*
   end = "}"
}

void whileStmnt() #WHILE :
{
   Token start;
} {
  start = "while" <RoundBracketOpen> ausdruck() <RoundBracketClose> stmnt()
}



void ausdruck() #void :
{
   Token ident;
} {
    LOOKAHEAD(2)
  (ident=<Identifier> {jjtThis.value = ident.image; } "=" ausdruck()) #EXPRESSION
  | junktoren()
}


void junktoren() #void :
{} {
   vergleich() (junktoren2())*
}

void junktoren2() #JUNKTOREN :
{ Token t; }
{
    t=<BinJunktor> {jjtThis.value = t.image;} vergleich()
}

void vergleich() #void :
{} {
   summe() (vergleich2())*
}

void vergleich2() #VERGLEICH :
{Token op;}
{
    (op=<BinVergleich> | op = <LessThan> | op = <GreaterThan>) {jjtThis.value = op.image;} summe()
}

void summe() #void :
{} {
    produkt() (summe2())*
}

void summe2() #MATH_OP_ADDSUB :
{Token op;}
{
    op=<OpSum> {jjtThis.value = op.image;} produkt()
}

void produkt() #void :
{} {
    unaer() (produkt2())*
}

void produkt2() #MATH_OP_MULDIV :
{Token op;}
{
    op=<OpProd> {jjtThis.value = op.image;} unaer()
}

void unaer() #void :
{} {
  unaer2() | atom()
}

void unaer2() #UNAER_OPERATOR :
{ Token op; }
{
    (op = <OpSum> | op = <OpUnaer>) {jjtThis.value = op.image;} atom()
}

void atom() #void :
{
    Token ident = null;
    Token inc=null;
} {
  identifier_increment()
  //| /*(inc = "++"| inc = "--")*/ ident=<Identifier>
  | ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
  | ident=<DoubleLiteral> {jjtThis.value = ident.image; } #ATOM_DBL
  | ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
  | <RoundBracketOpen> junktoren() <RoundBracketClose>
}

void identifier_increment() #ATOM_LITERAL :
{ Token ident; }
{
    // TODO needs semantic check later in the pipeline
    [identifier_increment_pre()] ident=<Identifier> {jjtThis.value = ident.image; } [identifier_increment_post()]
}

void identifier_increment_pre() #INCREMENT_PRE :
{ Token inc; }
{
    inc=<OpIncrement> {jjtThis.value = inc.image; }
}

void identifier_increment_post() #INCREMENT_POST :
{ Token inc; }
{
    inc=<OpIncrement> {jjtThis.value = inc.image; }
}
