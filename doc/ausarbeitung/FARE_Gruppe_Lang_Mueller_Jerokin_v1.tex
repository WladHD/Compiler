\documentclass[a4paper,11pt,numbers=noenddot]{article}

\usepackage[main=ngerman, english]{babel}
%\usepackage{natbib}
%\bibliographystyle{plainnat}
%\setcitestyle{square,aysep={},yysep={;}}
%\setcitestyle{authoryear,square,semicolon} 
%\setcitestyle{numbers,square}

\usepackage[latin1]{inputenc}
\usepackage[babel, german=quotes]{csquotes} % einfache Handhabung von quotations
\usepackage[backend=bibtex8,style=authoryear]{biblatex} %biblatex mit biber laden
\ExecuteBibliographyOptions{
	sorting=nyt, %Sortierung Autor, Titel, Jahr
	bibwarn=true, %Probleme mit den Daten, die Backend betreffen anzeigen
	isbn=false, %keine isbn anzeigen
	url=true, %keine url anzeigen
	maxcitenames=2,
	maxbibnames=99
}
\renewcommand*{\nameyeardelim}{\addcomma\space}
\addbibresource{res/literaturBibLatex.bib} %Bibliographiedateien laden

\setlength{\parindent}{1em}
\linespread{1.2}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=black,      
	urlcolor=black,
	citecolor=black,
	pdftitle={FARE Compiler} % PDFTITLE
}


\usepackage{geometry}
\usepackage{textpos} 
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}
\usepackage{graphicx}
\usepackage{float}
\usepackage{csquotes}
\usepackage{ifthen}
\usepackage{booktabs}
\usepackage{tabu}
\usepackage[inline]{enumitem}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{pifont}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{subfig}
\usepackage{ragged2e}
\usepackage{xcolor}

\newcommand\signature[2]{% Name; Department
	\noindent\begin{minipage}{6.5cm}
		\noindent\vspace{3cm}\par
		\noindent\rule{6.5cm}{1pt}\par
		\noindent\textbf{#1}\par
		\noindent#2%
\end{minipage}}

\geometry{a4paper, left=45mm, right=15mm, top=30mm, bottom=25mm, headsep=1cm, headheight=0cm}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\usepackage{fancyhdr}
\usepackage[nottoc]{tocbibind}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\fancyhf{}
\fancyhead[C]{\Roman{page}}
\pagestyle{fancy}

\fancypagestyle{fancy}{}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{black}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\newenvironment{changemargin}[2]{%
	\begin{list}{}{%
			\setlength{\topsep}{0pt}%
			\setlength{\leftmargin}{#1}%
			\setlength{\rightmargin}{#2}%
			\setlength{\listparindent}{\parindent}%
			\setlength{\itemindent}{\parindent}%
			\setlength{\parsep}{\parskip}%
		}%
		\item[]}{\end{list}}

\lstdefinelanguage{none}{
	identifierstyle=
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\footnotesize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}


\usepackage[printonlyused]{acronym}

\makeatletter
\renewcommand*\AC@acs[1]{%
	\expandafter\AC@get\csname fn@#1\endcsname\@firstoftwo{#1}}
\makeatother

%biblatex patch, working now
%\linespread{1.25}
%\makeatletter
%\def\blx@err@patch#1{}
%\makeatother

\usepackage{setspace}
\usepackage[automake]{glossaries}
\glsdisablehyper

\newglossary[nlg]{nu}{not}{ntn}{Not Used}

\newglossaryentry{Widget}
{
	type=nu,
	name=Widget,
	description={Ein Widget ist innerhalb des Dashboards ein Element, welches Informationen anzeigt und interaktiv verwendet werden kann},
	plural=Widgets,
	%nonumberlist
}

\makeglossaries

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\begin{document}
	\begin{titlepage}
		\begin{textblock}{6.5}(-2.5,-3)
			\begin{color}{accent}
				\rule{6.6cm}{33cm}    
			\end{color}
		\end{textblock}
		\begin{textblock}{6.5}(-2,-1)
			{\large \textsf{Ausarbeitung}}
		\end{textblock}
		
		\doublespacing
		\begin{textblock}{8.2}(3.1,1)
			{
				\noindent \LARGE 
				\textsf{\textbf{Entwicklung eines Compilers für die Sprache FARE zur Zielsprache Java \\[0.3cm]
			} }}
		\end{textblock}
		\onehalfspacing
		
		\begin{textblock}{8.2}(3.1,3.5)
			{\noindent \large
				\textsf{\textbf{Development of a compiler for the language FARE\\ to the target language Java  \\[0.3cm]
			} }}
		\end{textblock}
		
		\begin{textblock}{6}(3.1,5.5)
			\noindent
			\textsf{An der Fachhochschule Dortmund\\
				im Fachbereich Informatik\\
				Studiengang Medizinische Informatik Master\\
				im Modul Formale Sprachen und Compilerbau\\
				erstellte Ausarbeitung eines FARE-Compilers
			}
		\end{textblock}
		
		
		
		
		\begin{textblock}{6}(-2,7.5)\noindent
			\textsf{von \\Johannes Lang \\
				Matr.-Nr. 7217450 \\ [0.2cm]
				Henning Müller \\
				Matr.-Nr. 7105852 \\ [0.2cm]
				Wladislaw Jerokin \\
				Matr.-Nr. 7205290 \\ [1cm]
				Betreuung durch: \\
				Prof. Dr. Robert Rettinger \\ [1cm]
				%In enger Zusammenarbeit mit: \\
				%Dr. Georg Lodde \\ [1cm]
				Dortmund, \today
			}
		\end{textblock}
		
		%	\begin{textblock}{6.5}(-1,10.8)
			%		\noindent
			%			\textsf{An der Fachhochschule Dortmund\\
				%			im Fachbereich Informatik\\
				%			Studiengang Medizinische Informatik\\
				%			erstellte Projektarbeit fï¿½r das \\
				%			Modul Wissenschaftliches Arbeiten
				%		}
			%	\end{textblock}
		
	\end{titlepage}
	
	\onehalfspacing
	\setlength\arrayrulewidth{1.1pt}
	\newpage
	\tableofcontents
	
	\newpage
	\setcounter{page}{1}
	\fancyhf{}
	\fancyhead[C]{\thepage}
	\pagestyle{fancy}
	\fancypagestyle{fancy}{}
	
	\section{Einleitung}
	Grundlegend definiert sich ein Compiler als Programm, welches einen gegebenen Quellcode zu Maschinencode, Bytecode oder einer anderen Programmiersprache übersetzen kann \parencite[vgl.][]{RobertSheldon.2023}.
	Die Entwicklung eines solchen Compilers ist eine komplexe Aufgabe, die aus mehreren Teilgebieten besteht.
	In dieser Ausarbeitung werden folgende Teilgebiete behandelt:
	
	\begin{longtable}{|c|c|}
		\toprule{}
		Num & Name \\ \midrule  
		
		1 & Lexikalische Analyse \\
		
		2 & Syntaxanalyse  \\
		
		3 & Semantische Analyse  \\
		
		4 & Fehlerbehandlung  \\
		
		5 & Codeerzeugung  \\ \midrule
		
		\caption{Behandelte fünf Teilbereiche des Compilerbaus}
		\label{table:bereiche}
	\end{longtable}
	
	\noindent
	Die in dieser Ausarbeitung behandelte Aufgabe besteht darin, die Bereiche in Tabelle \ref{table:bereiche} für eine Scriptsprache für den Umgang mit Dateien und Pfaden zu entwickeln.
	Folgend werden die herausgearbeiteten Token, Grammatik und Semantik in jeweils eigenen Kapiteln beschrieben.
	
	\subsection{Herangehensweise}
	\label{sec:Herangehensweise}
	Der Compiler wird in Java geschrieben und benutzt die Bibliotheken JavaCC und die JavaCC-interne JJTree.
	Somit wird die Lexikalische Analyse und die Syntaxanalyse durch die definierte Grammatik durchgeführt.
	Um dies kurz auszuführen wird mit JavaCC geprüft, ob ein gegebener Quellcode zur definierten Sprache und Grammatik zugehört (Lexikalische Analyse).
	Durch erweiterte Annotation der Grammatik wird folgend der AST durch JJTree generiert (Syntaxanalyse).
	Falls keine Fehler vorliegen, wird der AST zur Semantischen Analyse und Fehlerbehandlung übergeben, wo auf semantische Korrektheit geprüft wird.
	Abschließend wird bei korrekter Semantik der AST zur Codeerzeugung übergeben, bei welcher vorerst Java Source Code erzeugt und danach compiliert wird.
	
	
	
	
	
	
	\newpage
	\section{Token}
	\label{sec:Token}
	\begin{lstlisting}[caption={Definierte JavaCC Token}, label=lst:token]
// de/fh/javacc/Grammar1.jjt, Zeile 20 - 54
<TypeMap: "Map">
| <TypeSet: "Set">
| <TypeSpecifiers: "int" | "char" | "String" | "boolean"| "Files" >
| <LBRACKET : "[">
| <RBRACKET : "]">
| <TypePath: "Path" >
| <IF: "if">
| <ELSE: "else">
| ";" |  ","
| <GBracketOpen: "{">
| <GBracketClose: "}">
| <TypeVoid: "void">
| <While: "while">
| <For: "for">
| <SimpleEquals: "="| "+=" |"-=" |"*="| "/=" | "%=" >
| <Point: ".">
| <RoundBracketOpen: "(">
| <RoundBracketClose: ")">
| <BooleanLiteral: "true" | "false" >
| <LessThan: "<">
| <GreaterThan: ">">
| <BinVergleich : ">="  | "<=" | "==" | "!=" >
| <BinJunktor : "||" | "&&" >
| <OpSum : "+" | "-" >
| <OpUnaer: "!">
| <OpIncrement: "++" | "--">
| <OpProd : "*" | "%">
| <FWD: "/">
| <Return : "return">
| <Identifier : ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])* >
| <IntegerLiteral : "0" | (["1"-"9"] (["0"-"9"])*) >
| <StringLiteral: "\""(~["\"","\n"])*"\"" >
| <CharLiteral:"'" (~["'","\n"]) "'" >
| <PathLiteral:".."|  ["A"-"Z"] ":">
	\end{lstlisting}
	
	\noindent
	Insgesamt werden 34 verschiedene Token in Listing \ref{lst:token} definiert. Wenn nicht anders genannt, wird im Folgenden bei Zeilenangaben Listing \ref{lst:token} referenziert.
	Die akzeptierten Variablentypen der Programmiersprache sind \textit{Map, Set, int, char, String, boolean, Files, Path} (vgl. Z. 2 - 4, 7).
	Methoden erweitern diese um den Typen \textit{void} (vgl. Z. 13).
	Zulässige Ausdrücke sind \textit{if, else, while, for} (vgl. Z. 8, 9, 14, 15).
	Zuweisungen und Operationen werden nach dem Java Operator Vorrang eingeteilt \parencite[vgl.][]{javatpoint.2023}.
	Diese werden in Zeilen 5, 6 sowie 16 bis 29 definiert.
	Als grundlegende Token werden \textit{Identifier} und Literale für \textit{Integer, String, Char und Path} definiert.
	Bei \textit{PathLiteral} handelt es sich um eine Sonderform. Der Pfad an sich wird durch grammatische Regeln definiert und ist in Kapitel \ref{sec:Grammatik} beschrieben.
	
	\section{Grammatik}
	\label{sec:Grammatik}
	Wie in Kapitel \ref{sec:Herangehensweise} genannt, wird JavaCC und JJTree genutzt. Um die erweiterte Grammatik zu demonstrieren, wird im Folgenden ein Beispiel angebracht.
	
		\begin{lstlisting}[caption={Beispiel der erweiterten Grammatik für Nutzung von JavaCC und JJTree anhand der Regel atom()}, label=lst:atom]
// de/fh/javacc/Grammar1.jjt, Zeile 436 - 449
void atom() #void :
{
	Token ident = null;
} {
	LOOKAHEAD(2)
	methodOrVariableCaller()
	| ident=<Identifier> {jjtThis.value = ident.image; } #ATOM_VARIABLE
	| ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
	| ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
	| ident = <StringLiteral> {jjtThis.value = ident.image; } #ATOM_STRING
	| ident = <CharLiteral> {jjtThis.value = ident.image; } #ATOM_CHAR
	| (LOOKAHEAD(3) array()| atomset()| atommap())
	| <RoundBracketOpen> junktoren() <RoundBracketClose>
}
	\end{lstlisting}
	
	\noindent
	Ähnlich zum reinen JavaCC können Regeln für die Grammatik definiert werden (vgl. Listing \ref{lst:atom}, Z. 7 - 16).
	Die Erweiterung liegt in der Annotation für die Erstellung des AST, welche die Werte \textit{void, ATOM\_VARIABLE, ATOM\_INT, ATOM\_BOL, ATOM\_STRING, ATOM\_CHAR} annehmen kann. Im Sachkontext wird im Normalfall keine Node im AST angelegt (vgl. Listing \ref{lst:atom}, Z. 2).
	Sollte jedoch eine Regel in den Zeilen 8 - 12 angewandt werden, so wird ein entsprechend benannter Knoten zum AST mit dem Inhalt des Tokens hinzugefügt (vgl. Listing \ref{lst:atom}, Z. 8 - 12). Nach diesem Prinzip wird für alle Regeln an sinnvollen Stellen ein Knoten zum AST hinzugefügt. Diese Kombination von JavaCC und JJTree ermöglicht die simultane Lexikalische Analyse und Syntaxanalyse.
	
	Nach der Anführung eines Beispiels wird folgend grob die Grammatik beschrieben. Insgesamt liegen 51 grammatische Regeln vor sowie 51 verschiedene AST Knotentypen.
\begin{lstlisting}[caption={Wurzel des AST sowie erste Regel der Grammatik}, label=lst:rootNode]
// de/fh/javacc/Grammar1.jjt, Zeile 62 - 70
SimpleNode compilationUnit() #PROGRAM :
{
	boolean first = true;
	SimpleNode result = null;
} {(
	(LOOKAHEAD(2) stmnt() | decl() | (methodOrVariableCaller() ";")) { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); }
	)*
	{ return result; }
}
\end{lstlisting}	
	
	\noindent
	Da die Ausführung der ersten Regel einen AST als Rückgabewert liefert, stellt die Regel in Listing \ref{lst:rootNode} eine Sonderform dar.
	Wie erkannt werden kann, wird in jedem Fall ein neuer Knoten mit dem Namen \textit{PROGRAM} erzeugt.
	Unter diesem Knoten können nun beliebig viele \textit{stmnt(), decl()} und Methodenaufrufe vorliegen.
	Fortführend wird beispielhaft die Regel zur Erzeugung des Literals \textit{Path} angebracht.
	\begin{lstlisting}[caption={Grammatikregel für das Literal Path}, label=lst:pathNode]
// de/fh/javacc/Grammar1.jjt, Zeile 314 - 325
void path()  #ATOM_PATHELEMENT:
{Token t;
	Token t1 = null;
}

{
	
	(
	t = <PathLiteral> {jjtThis.value = t.image;} |
	t = <Point> {jjtThis.value = t.image;}|
	t = <Identifier> ["." t1= <Identifier>]{jjtThis.value = (t.image +  (t1 != null ? "." + t1.image : ""));}) [("/" | "\\") [path()]]
}
	\end{lstlisting}
	
	\noindent
	Die Zeilen 10 und 11 in Listing \ref{lst:pathNode} sagen aus, dass ein Teil des Pfades aus \textit{., .., <Laufwerkbuchstabe>:} bestehen kann.
	Weiterführend kann der Pfad aus einem Namen bestehen und anschließend nach einen Separator \textit{$\backslash$, /} wiederholt werden.
	Momentan besteht die Limitation des Pfades daraus, dass dieser keine Leerzeichen enthalten darf.
	
	\noindent
	Nach diesem Muster werden die restlichen Regeln ebenfalls umgesetzt. Wie einleitend genannt, gibt es 51 verschiedene AST Typen, die im Folgenden alphabetisch aufgelistet werden.
	
	
	\begin{longtable}{|c|}
		\toprule{}
		 AST Typ \\ \midrule  
		ASTARRAY\_ELEMENT \\
		ASTARRAYAUFRUF \\
		ASTATOM\_ARRAY \\
		ASTATOM\_BOL \\
		ASTATOM\_CHAR \\
		ASTATOM\_INT \\
		ASTATOM\_MAP \\
		ASTATOM\_PATH \\
		ASTATOM\_PATHELEMENT \\
		ASTATOM\_SET \\
		ASTATOM\_STRING \\
		ASTATOM\_VARIABLE \\
		ASTBLOCK \\
		ASTCONCLUDED\_VAR\_DEC \\
		ASTCONDITION \\
		ASTDECL \\
		ASTDECL\_METHOD\_PARAMS \\
		ASTELSE \\
		ASTFOR \\
		ASTFOR\_BODY \\
		ASTFOR\_BODY\_EACH \\
		ASTFOR\_BODY\_NORMAL \\
		ASTFORCOND \\
		ASTFORINIT \\
		ASTFOROPER \\
		ASTGET\_METHOD\_PARAMS \\
		ASTGET\_VAR\_METHOD \\
		ASTIF \\
		ASTKOMPLEX\_TYPE \\
		ASTMAP\_KEY \\
		ASTMAP\_PAIR \\
		ASTMAP\_VALUE \\
		ASTMETHDECL \\
		ASTOPERATION\_PRIO\_4\_AND\_3 \\
		ASTOPERATION\_PRIO\_9 \\
		ASTOPERATION\_PRIO\_11 \\
		ASTOPERATION\_PRIO\_12 \\
		ASTOPERATION\_PRIO\_13 \\
		ASTOPERATION\_PRIO\_14 \\
		ASTPARAM \\
		ASTPARAM\_PAIR \\
		ASTPROGRAM \\
		ASTREQUESTER\_VAR\_METHOD \\
		ASTRETURN \\
		ASTSET\_ELEMENT \\
		ASTSTATEMENT \\
		ASTTYPE \\
		ASTTYPE\_ARRAY \\
		ASTVAR\_METHOD\_NAME \\
		ASTVARIABLE\_ASSIGNMENT\_PRIO\_1 \\
		ASTWHILE \\ \midrule
		
		\caption{Alle möglichen Typen von AST Knoten}
		\label{table:alleNodes}
	\end{longtable}
	
	\noindent
	Um die Funktionsweise der Grammatik zu verdeutlichen, wird ein AST erzeugt und verschriftlicht.
\begin{lstlisting}[caption={Beispiel eines akzeptierten Source Code}, label=lst:bsplCode]
// resources/beispiel.txt
void main() {
	Path p = D:\Arbeit\testing\test2;
	Set<int> setA = {0,1,2};
	
	int x = 5;
	int y;
	int z = y = x++ + x / 2;
}
\end{lstlisting}

\begin{lstlisting}[caption={Erzeugter AST eines akzeptierten Source Codes in Listing \ref{lst:bsplCode}}, label=lst:bsplAst]
// Ausgabe
PROGRAM = null
 DECL = null
  TYPE = void
   VAR_METHOD_NAME = main
   METHDECL = null
    DECL_METHOD_PARAMS = null
    BLOCK = null
     DECL = null
      TYPE = Path
      VAR_METHOD_NAME = p
      CONCLUDED_VAR_DEC = null
       ATOM_PATH = null
        ATOM_PATHELEMENT = D:
         ATOM_PATHELEMENT = Arbeit
          ATOM_PATHELEMENT = testing
           ATOM_PATHELEMENT = test2
     DECL = null
      TYPE = Set
       KOMPLEX_TYPE = null
        TYPE = int
      VAR_METHOD_NAME = setA
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        ATOM_SET = null
         SET_ELEMENT = null
          ATOM_INT = 0
         SET_ELEMENT = null
          ATOM_INT = 1
         SET_ELEMENT = null
          ATOM_INT = 2
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = x
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        ATOM_INT = 5
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = y
      CONCLUDED_VAR_DEC = null
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = z
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        VAR_METHOD_NAME = y
         VARIABLE_ASSIGNMENT_PRIO_1 = =
          OPERATION_PRIO_14 = ++
           REQUESTER_VAR_METHOD = x
          OPERATION_PRIO_11 = +
           REQUESTER_VAR_METHOD = x
           OPERATION_PRIO_12 = /
            ATOM_INT = 2
\end{lstlisting}

\newpage
\section{Semantik}
Nach der Erzeugung des AST wird dieser der semantischen Prüfung übergeben.
Derzeitig erfolgen nachstehend genannte Prüfungen.

\begin{longtable}{|c|c|}
	\toprule{}
	Num & Name \\ \midrule  
	
	1 & Deklaration von Variablen und Methoden \\
	
	2 & Initialisierung von Variablen und Methoden  \\ \midrule
	
	\caption{Stichpunkte zur Umsetzung der semantischen Prüfung}
	\label{table:semanticCheck}
\end{longtable}




	
	


%\newpage
%\addcontentsline{toc}{section}{Glossar}
%\printglossary[type=main]

\newpage
\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\section*{Abkürzungsverzeichnis}
\begin{acronym}[BA]
\acro{patdb}[SHIP - DB]{SHIP - Patientendashboard}
\acro{rapp}[React - App]{React - Applikation}
\acro{rmod}[Modul]{React - Modul}
\acroplural{rmod}[Moduls]{React - Moduls}
\acro{rcom}[Komponente]{React - Komponente}
\acroplural{rcom}[Komponenten]{React - Komponenten}
\end{acronym}

\newpage
%\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\listoffigures

\newpage
\listoftables

\newpage
\addcontentsline{toc}{section}{Listings}
\lstlistoflistings

\newpage
\addcontentsline{toc}{section}{Literatur}
%\bibliography{literatur}
\printbibliography

\newpage
\pagenumbering{gobble}
%\addcontentsline{toc}{section}{Eigenständigkeitserklärungen}
\section*{Versicherung der Eigenständigkeit}
Hiermit versichere ich, dass
ich die vorliegende Arbeit selbständig angefertigt und mich keiner fremden Hilfe bedient sowie keine
anderen als die angegebenen Quellen und Hilfsmittel benutzt habe. Alle Stellen, die wörtlich oder
sinngemäß veröffentlichten oder nicht veröffentlichten Schriften und anderen Quellen entnommen sind,
habe ich als solche kenntlich gemacht. Diese Arbeit hat in gleicher oder ähnlicher Form noch keiner
Prüfungsbehörde vorgelegen.

\signature{Johannes Lang \\ \textnormal{\textit{Matr. 7217450}} \\
	Henning Müller \\ \textnormal{\textit{Matr. 7105852}} \\
	Wladislaw Jerokin \\ \textnormal{\textit{Matr. 7205290}}
	}{Dortmund, den \today}

\end{document}