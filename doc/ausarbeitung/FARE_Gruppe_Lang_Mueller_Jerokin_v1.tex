\documentclass[a4paper,11pt,numbers=noenddot]{article}

\usepackage[main=ngerman, english]{babel}
%\usepackage{natbib}
%\bibliographystyle{plainnat}
%\setcitestyle{square,aysep={},yysep={;}}
%\setcitestyle{authoryear,square,semicolon} 
%\setcitestyle{numbers,square}

\usepackage[latin1]{inputenc}
\usepackage[babel, german=quotes]{csquotes} % einfache Handhabung von quotations
\usepackage[backend=bibtex8,style=authoryear]{biblatex} %biblatex mit biber laden
\ExecuteBibliographyOptions{
	sorting=nyt, %Sortierung Autor, Titel, Jahr
	bibwarn=true, %Probleme mit den Daten, die Backend betreffen anzeigen
	isbn=false, %keine isbn anzeigen
	url=true, %keine url anzeigen
	maxcitenames=2,
	maxbibnames=99
}
\renewcommand*{\nameyeardelim}{\addcomma\space}
\addbibresource{res/literaturBibLatex.bib} %Bibliographiedateien laden

\setlength{\parindent}{1em}
\linespread{1.2}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=black,      
	urlcolor=black,
	citecolor=black,
	pdftitle={FARE Compiler} % PDFTITLE
}


\usepackage{geometry}
\usepackage{textpos} 
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}
\usepackage{graphicx}
\usepackage{float}
\usepackage{csquotes}
\usepackage{ifthen}
\usepackage{booktabs}
\usepackage{tabu}
\usepackage[inline]{enumitem}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{pifont}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{subfig}
\usepackage{ragged2e}
\usepackage{xcolor}

\newcommand\signature[2]{% Name; Department
	\noindent\begin{minipage}{6.5cm}
		\noindent\vspace{3cm}\par
		\noindent\rule{6.5cm}{1pt}\par
		\noindent\textbf{#1}\par
		\noindent#2%
\end{minipage}}

\geometry{a4paper, left=45mm, right=15mm, top=30mm, bottom=25mm, headsep=1cm, headheight=0cm}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\usepackage{fancyhdr}
\usepackage[nottoc]{tocbibind}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\fancyhf{}
\fancyhead[C]{\Roman{page}}
\pagestyle{fancy}

\fancypagestyle{fancy}{}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{black}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\newenvironment{changemargin}[2]{%
	\begin{list}{}{%
			\setlength{\topsep}{0pt}%
			\setlength{\leftmargin}{#1}%
			\setlength{\rightmargin}{#2}%
			\setlength{\listparindent}{\parindent}%
			\setlength{\itemindent}{\parindent}%
			\setlength{\parsep}{\parskip}%
		}%
		\item[]}{\end{list}}

\lstdefinelanguage{none}{
	identifierstyle=
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\footnotesize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}


\usepackage[printonlyused]{acronym}

\makeatletter
\renewcommand*\AC@acs[1]{%
	\expandafter\AC@get\csname fn@#1\endcsname\@firstoftwo{#1}}
\makeatother

%biblatex patch, working now
%\linespread{1.25}
%\makeatletter
%\def\blx@err@patch#1{}
%\makeatother

\usepackage{setspace}
\usepackage[automake]{glossaries}
\glsdisablehyper

\newglossary[nlg]{nu}{not}{ntn}{Not Used}

\newglossaryentry{Widget}
{
	type=nu,
	name=Widget,
	description={Ein Widget ist innerhalb des Dashboards ein Element, welches Informationen anzeigt und interaktiv verwendet werden kann},
	plural=Widgets,
	%nonumberlist
}

\makeglossaries

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\begin{document}
	\begin{titlepage}
		\begin{textblock}{6.5}(-2.5,-3)
			\begin{color}{accent}
				\rule{6.6cm}{33cm}    
			\end{color}
		\end{textblock}
		\begin{textblock}{6.5}(-2,-1)
			{\large \textsf{Ausarbeitung}}
		\end{textblock}
		
		\doublespacing
		\begin{textblock}{8.2}(3.1,1)
			{
				\noindent \LARGE 
				\textsf{\textbf{Entwicklung eines Compilers für die Sprache FARE zur Zielsprache Java \\[0.3cm]
			} }}
		\end{textblock}
		\onehalfspacing
		
		\begin{textblock}{8.2}(3.1,3.5)
			{\noindent \large
				\textsf{\textbf{Development of a compiler for the language FARE\\ to the target language Java  \\[0.3cm]
			} }}
		\end{textblock}
		
		\begin{textblock}{6}(3.1,5.5)
			\noindent
			\textsf{An der Fachhochschule Dortmund\\
				im Fachbereich Informatik\\
				Studiengang Medizinische Informatik Master\\
				im Modul Formale Sprachen und Compilerbau\\
				erstellte Ausarbeitung eines FARE-Compilers
			}
		\end{textblock}
		
		
		
		
		\begin{textblock}{6}(-2,7.5)\noindent
			\textsf{von \\Johannes Lang \\
				Matr.-Nr. 7217450 \\ [0.2cm]
				Henning Müller \\
				Matr.-Nr. 7105852 \\ [0.2cm]
				Wladislaw Jerokin \\
				Matr.-Nr. 7205290 \\ [1cm]
				Betreuung durch: \\
				Prof. Dr. Robert Rettinger \\ [1cm]
				%In enger Zusammenarbeit mit: \\
				%Dr. Georg Lodde \\ [1cm]
				Dortmund, \today
			}
		\end{textblock}
		
		%	\begin{textblock}{6.5}(-1,10.8)
			%		\noindent
			%			\textsf{An der Fachhochschule Dortmund\\
				%			im Fachbereich Informatik\\
				%			Studiengang Medizinische Informatik\\
				%			erstellte Projektarbeit fï¿½r das \\
				%			Modul Wissenschaftliches Arbeiten
				%		}
			%	\end{textblock}
		
	\end{titlepage}
	
	\onehalfspacing
	\setlength\arrayrulewidth{1.1pt}
	\newpage
	\tableofcontents
	
	\newpage
	\setcounter{page}{1}
	\fancyhf{}
	\fancyhead[C]{\thepage}
	\pagestyle{fancy}
	\fancypagestyle{fancy}{}
	
	\section{Einleitung}
	Grundlegend definiert sich ein Compiler als Programm, welches einen gegebenen Quellcode zu Maschinencode, Bytecode oder einer anderen Programmiersprache übersetzen kann \parencite[vgl.][]{RobertSheldon.2023}.
	Die Entwicklung eines solchen Compilers ist eine komplexe Aufgabe, die aus mehreren Teilgebieten besteht.
	In dieser Ausarbeitung werden folgende Teilgebiete behandelt:
	
	\begin{longtable}{|c|c|}
		\toprule{}
		Num & Name \\ \midrule  
		
		1 & Lexikalische Analyse \\
		
		2 & Syntaxanalyse  \\
		
		3 & Semantische Analyse  \\
		
		4 & Fehlerbehandlung  \\
		
		5 & Codeerzeugung  \\ \midrule
		
		\caption{Behandelte fünf Teilbereiche des Compilerbaus}
		\label{table:bereiche}
	\end{longtable}
	
	\noindent
	Die in dieser Ausarbeitung behandelte Aufgabe besteht darin, die Bereiche in Tabelle \ref{table:bereiche} für eine Scriptsprache für den Umgang mit Dateien und Pfaden zu entwickeln.
	Folgend werden die herausgearbeiteten Token, Grammatik und Semantik in jeweils eigenen Kapiteln beschrieben.
	
	\subsection{Herangehensweise}
	\label{sec:Herangehensweise}
	Der Compiler wird in Java geschrieben und benutzt die Bibliotheken JavaCC und die JavaCC-interne JJTree.
	Somit wird die Lexikalische Analyse und die Syntaxanalyse durch die definierte Grammatik durchgeführt.
	Um dies kurz auszuführen wird mit JavaCC geprüft, ob ein gegebener Quellcode zur definierten Sprache und Grammatik zugehört (Lexikalische Analyse).
	Durch erweiterte Annotation der Grammatik wird folgend der AST durch JJTree generiert (Syntaxanalyse).
	Falls keine Fehler vorliegen, wird der AST zur Semantischen Analyse und Fehlerbehandlung übergeben, wo auf semantische Korrektheit geprüft wird.
	Abschließend wird bei korrekter Semantik der AST zur Codeerzeugung übergeben, bei welcher vorerst Java Source Code erzeugt und danach compiliert wird.
	
	
	
	
	
	
	\newpage
	\section{Token}
	\label{sec:Token}
	\begin{lstlisting}[caption={Definierte JavaCC Token}, label=lst:token]
// de/fh/javacc/Grammar1.jjt, Zeile 20 - 54
<TypeMap: "Map">
| <TypeSet: "Set">
| <TypeSpecifiers: "int" | "char" | "String" | "boolean"| "Files" >
| <LBRACKET : "[">
| <RBRACKET : "]">
| <TypePath: "Path" >
| <IF: "if">
| <ELSE: "else">
| ";" |  ","
| <GBracketOpen: "{">
| <GBracketClose: "}">
| <TypeVoid: "void">
| <While: "while">
| <For: "for">
| <SimpleEquals: "="| "+=" |"-=" |"*="| "/=" | "%=" >
| <Point: ".">
| <RoundBracketOpen: "(">
| <RoundBracketClose: ")">
| <BooleanLiteral: "true" | "false" >
| <LessThan: "<">
| <GreaterThan: ">">
| <BinVergleich : ">="  | "<=" | "==" | "!=" >
| <BinJunktor : "||" | "&&" >
| <OpSum : "+" | "-" >
| <OpUnaer: "!">
| <OpIncrement: "++" | "--">
| <OpProd : "*" | "%">
| <FWD: "/">
| <Return : "return">
| <Identifier : ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])* >
| <IntegerLiteral : "0" | (["1"-"9"] (["0"-"9"])*) >
| <StringLiteral: "\""(~["\"","\n"])*"\"" >
| <CharLiteral:"'" (~["'","\n"]) "'" >
| <PathLiteral:".."|  ["A"-"Z"] ":">
	\end{lstlisting}
	
	\noindent
	Insgesamt werden 34 verschiedene Token in Listing \ref{lst:token} definiert. Wenn nicht anders genannt, wird im Folgenden bei Zeilenangaben Listing \ref{lst:token} referenziert.
	Die akzeptierten Variablentypen der Programmiersprache sind \textit{Map, Set, int, char, String, boolean, Files, Path} (vgl. Z. 2 - 4, 7).
	Methoden erweitern diese um den Typen \textit{void} (vgl. Z. 13).
	Zulässige Ausdrücke sind \textit{if, else, while, for} (vgl. Z. 8, 9, 14, 15).
	Zuweisungen und Operationen werden nach dem Java Operator Vorrang eingeteilt \parencite[vgl.][]{javatpoint.2023}.
	Diese werden in Zeilen 5, 6 sowie 16 bis 29 definiert.
	Als grundlegende Token werden \textit{Identifier} und Literale für \textit{Integer, String, Char und Path} definiert.
	Bei \textit{PathLiteral} handelt es sich um eine Sonderform. Der Pfad an sich wird durch grammatische Regeln definiert und ist in Kapitel \ref{sec:Grammatik} beschrieben.
	
	\section{Grammatik}
	\label{sec:Grammatik}
	Wie in Kapitel \ref{sec:Herangehensweise} genannt, wird JavaCC und JJTree genutzt. Um die erweiterte Grammatik zu demonstrieren, wird im Folgenden ein Beispiel angebracht.
	
		\begin{lstlisting}[caption={Beispiel der erweiterten Grammatik für Nutzung von JavaCC und JJTree anhand der Regel atom()}, label=lst:atom]
// de/fh/javacc/Grammar1.jjt, Zeile 436 - 449
void atom() #void :
{
	Token ident = null;
} {
	LOOKAHEAD(2)
	methodOrVariableCaller()
	| ident=<Identifier> {jjtThis.value = ident.image; } #ATOM_VARIABLE
	| ident=<IntegerLiteral> {jjtThis.value = ident.image; } #ATOM_INT
	| ident=<BooleanLiteral> {jjtThis.value = ident.image; } #ATOM_BOL
	| ident = <StringLiteral> {jjtThis.value = ident.image; } #ATOM_STRING
	| ident = <CharLiteral> {jjtThis.value = ident.image; } #ATOM_CHAR
	| (LOOKAHEAD(3) array()| atomset()| atommap())
	| <RoundBracketOpen> junktoren() <RoundBracketClose>
}
	\end{lstlisting}
	
	\noindent
	Ähnlich zum reinen JavaCC können Regeln für die Grammatik definiert werden (vgl. Listing \ref{lst:atom}, Z. 7 - 16).
	Die Erweiterung liegt in der Annotation für die Erstellung des AST, welche die Werte \textit{void, ATOM\_VARIABLE, ATOM\_INT, ATOM\_BOL, ATOM\_STRING, ATOM\_CHAR} annehmen kann. Im Sachkontext wird im Normalfall keine Node im AST angelegt (vgl. Listing \ref{lst:atom}, Z. 2).
	Sollte jedoch eine Regel in den Zeilen 8 - 12 angewandt werden, so wird ein entsprechend benannter Knoten zum AST mit dem Inhalt des Tokens hinzugefügt (vgl. Listing \ref{lst:atom}, Z. 8 - 12). Nach diesem Prinzip wird für alle Regeln an sinnvollen Stellen ein Knoten zum AST hinzugefügt. Diese Kombination von JavaCC und JJTree ermöglicht die simultane Lexikalische Analyse und Syntaxanalyse.
	
	Nach der Anführung eines Beispiels wird folgend grob die Grammatik beschrieben. Insgesamt liegen 51 grammatische Regeln vor sowie 51 verschiedene AST Knotentypen.
\begin{lstlisting}[caption={Wurzel des AST sowie erste Regel der Grammatik}, label=lst:rootNode]
// de/fh/javacc/Grammar1.jjt, Zeile 62 - 70
SimpleNode compilationUnit() #PROGRAM :
{
	boolean first = true;
	SimpleNode result = null;
} {(
	(LOOKAHEAD(2) stmnt() | decl() | (methodOrVariableCaller() ";")) { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); }
	)*
	{ return result; }
}
\end{lstlisting}	
	
	\noindent
	Da die Ausführung der ersten Regel einen AST als Rückgabewert liefert, stellt die Regel in Listing \ref{lst:rootNode} eine Sonderform dar.
	Wie erkannt werden kann, wird in jedem Fall ein neuer Knoten mit dem Namen \textit{PROGRAM} erzeugt.
	Unter diesem Knoten können nun beliebig viele \textit{stmnt(), decl()} und Methodenaufrufe vorliegen.
	Fortführend wird beispielhaft die Regel zur Erzeugung des Literals \textit{Path} angebracht.
	\begin{lstlisting}[caption={Grammatikregel für das Literal Path}, label=lst:pathNode]
// de/fh/javacc/Grammar1.jjt, Zeile 314 - 325
void path()  #ATOM_PATHELEMENT:
{Token t;
	Token t1 = null;
}

{
	
	(
	t = <PathLiteral> {jjtThis.value = t.image;} |
	t = <Point> {jjtThis.value = t.image;}|
	t = <Identifier> ["." t1= <Identifier>]{jjtThis.value = (t.image +  (t1 != null ? "." + t1.image : ""));}) [("/" | "\\") [path()]]
}
	\end{lstlisting}
	
	\noindent
	Die Zeilen 10 und 11 in Listing \ref{lst:pathNode} sagen aus, dass ein Teil des Pfades aus \textit{., .., <Laufwerkbuchstabe>:} bestehen kann.
	Weiterführend kann der Pfad aus einem Namen bestehen und anschließend nach einen Separator \textit{$\backslash$, /} wiederholt werden.
	Momentan besteht die Limitation des Pfades daraus, dass dieser keine Leerzeichen enthalten darf.
	
	\noindent
	Nach diesem Muster werden die restlichen Regeln ebenfalls umgesetzt. Wie einleitend genannt, gibt es 51 verschiedene AST Typen, die im Folgenden alphabetisch aufgelistet werden.
	
	
	\begin{longtable}{|c|}
		\toprule{}
		 AST Typ \\ \midrule  
		ASTARRAY\_ELEMENT \\
		ASTARRAYAUFRUF \\
		ASTATOM\_ARRAY \\
		ASTATOM\_BOL \\
		ASTATOM\_CHAR \\
		ASTATOM\_INT \\
		ASTATOM\_MAP \\
		ASTATOM\_PATH \\
		ASTATOM\_PATHELEMENT \\
		ASTATOM\_SET \\
		ASTATOM\_STRING \\
		ASTATOM\_VARIABLE \\
		ASTBLOCK \\
		ASTCONCLUDED\_VAR\_DEC \\
		ASTCONDITION \\
		ASTDECL \\
		ASTDECL\_METHOD\_PARAMS \\
		ASTELSE \\
		ASTFOR \\
		ASTFOR\_BODY \\
		ASTFOR\_BODY\_EACH \\
		ASTFOR\_BODY\_NORMAL \\
		ASTFORCOND \\
		ASTFORINIT \\
		ASTFOROPER \\
		ASTGET\_METHOD\_PARAMS \\
		ASTGET\_VAR\_METHOD \\
		ASTIF \\
		ASTKOMPLEX\_TYPE \\
		ASTMAP\_KEY \\
		ASTMAP\_PAIR \\
		ASTMAP\_VALUE \\
		ASTMETHDECL \\
		ASTOPERATION\_PRIO\_4\_AND\_3 \\
		ASTOPERATION\_PRIO\_9 \\
		ASTOPERATION\_PRIO\_11 \\
		ASTOPERATION\_PRIO\_12 \\
		ASTOPERATION\_PRIO\_13 \\
		ASTOPERATION\_PRIO\_14 \\
		ASTPARAM \\
		ASTPARAM\_PAIR \\
		ASTPROGRAM \\
		ASTREQUESTER\_VAR\_METHOD \\
		ASTRETURN \\
		ASTSET\_ELEMENT \\
		ASTSTATEMENT \\
		ASTTYPE \\
		ASTTYPE\_ARRAY \\
		ASTVAR\_METHOD\_NAME \\
		ASTVARIABLE\_ASSIGNMENT\_PRIO\_1 \\
		ASTWHILE \\ \midrule
		
		\caption{Alle möglichen Typen von AST Knoten}
		\label{table:alleNodes}
	\end{longtable}
	
	\noindent
	Um die Funktionsweise der Grammatik zu verdeutlichen, wird ein AST in Listing \ref{lst:bsplAst} aus dem Quelltext in Listing \ref{lst:bsplCode} erzeugt und verschriftlicht.
\begin{lstlisting}[caption={Beispiel eines akzeptierten Source Code}, label=lst:bsplCode]
// resources/beispiel.txt
void main() {
	Path p = D:\Arbeit\testing\test2;
	Set<int> setA = {0,1,2};
	
	int x = 5;
	int y;
	int z = y = x++ + x / 2;
}
\end{lstlisting}

\begin{lstlisting}[caption={Erzeugter AST eines akzeptierten Source Codes in Listing \ref{lst:bsplCode}}, label=lst:bsplAst]
// Ausgabe
PROGRAM = null
 DECL = null
  TYPE = void
   VAR_METHOD_NAME = main
   METHDECL = null
    DECL_METHOD_PARAMS = null
    BLOCK = null
     DECL = null
      TYPE = Path
      VAR_METHOD_NAME = p
      CONCLUDED_VAR_DEC = null
       ATOM_PATH = null
        ATOM_PATHELEMENT = D:
         ATOM_PATHELEMENT = Arbeit
          ATOM_PATHELEMENT = testing
           ATOM_PATHELEMENT = test2
     DECL = null
      TYPE = Set
       KOMPLEX_TYPE = null
        TYPE = int
      VAR_METHOD_NAME = setA
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        ATOM_SET = null
         SET_ELEMENT = null
          ATOM_INT = 0
         SET_ELEMENT = null
          ATOM_INT = 1
         SET_ELEMENT = null
          ATOM_INT = 2
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = x
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        ATOM_INT = 5
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = y
      CONCLUDED_VAR_DEC = null
     DECL = null
      TYPE = int
      VAR_METHOD_NAME = z
      CONCLUDED_VAR_DEC = null
       VARIABLE_ASSIGNMENT_PRIO_1 = =
        VAR_METHOD_NAME = y
         VARIABLE_ASSIGNMENT_PRIO_1 = =
          OPERATION_PRIO_14 = ++
           REQUESTER_VAR_METHOD = x
          OPERATION_PRIO_11 = +
           REQUESTER_VAR_METHOD = x
           OPERATION_PRIO_12 = /
            ATOM_INT = 2
\end{lstlisting}

\newpage
\section{Semantik}
Nach der Erzeugung des AST wird dieser der semantischen Prüfung übergeben.
Derzeitig erfolgen nachstehend genannte Prüfungen.

\begin{longtable}{|c|c|}
	\toprule{}
	Num & Name \\ \midrule  
	
	1 & Deklaration von Variablen und Methoden \\
	
	2 & Initialisierung von Variablen und Methoden  \\ \midrule
	
	\caption{Umsetzung der semantischen Prüfung}
	\label{table:semanticCheck}
\end{longtable}

\noindent
Die Bereiche 3 und 4 in Tabelle \ref{table:bereiche} sollen durch die semantische Prüfung abgedeckt werden.
\begin{lstlisting}[caption={Erzeugter AST eines akzeptierten Source Codes in Listing \ref{lst:bsplCode}}, label=lst:semanticCode]
void main() {
	int x;
	int x;
	
	int y = "56";
	int y = 56;
}

void test1() { int test = 5; }

void test2() { int test = 6; }

\end{lstlisting}

\noindent
Anfangend mit \textit{Deklaration von Variablen und Methoden} in Tabelle \ref{table:semanticCheck} wird geprüft, ob eine Variable oder Methode bereits deklariert wurde. Es wird mit Closures gearbeitet, um sicherzustellen, dass gleich benannte Variablen in verschiedenen Methoden korrekterweise zugelassen werden (vgl. Listing \ref{lst:semanticCode}, Z. 9, 11). Wiederholte Deklarationen werden nicht zugelassen (vgl. Listing \ref{lst:semanticCode}, Z. 2, 3).

\noindent
\textit{Initialisierung von Variablen und Methoden} in Tabelle \ref{table:semanticCheck} prüft, ob der zugewiesene Wert auch dem Datentyp der deklarierten Variable entspricht. Da \textit{"56"} vom Tokentyp \textit{StringLiteral} und die deklarierte Variable \textit{y} vom Datentyp \textit{int} ist, wird die Zuweisung abgelehnt.
Wird in der semantischen Prüfung festgestellt, dass ein Fehler vorliegt, so wird eine Exception geworfen, welche den Compiler mit einer Fehlermeldung abbricht.

\newpage
\section{Übersetzung}
Die Übersetzung ist der letzte Schritt in Tabelle \ref{table:bereiche} und ist dafür verantwortlich, den erhaltenen AST zu Java Source Code zu übersetzen.
Dieser wird im Anschluss compiliert und zu einer ausführbaren jar-Datei verpackt.
Die Funktionsweise des Übersetzers liegt darin, über den AST zu iterieren und die Knoten mit passendem Java Code zu versehen.
\begin{lstlisting}[caption={Beispiel eines akzeptierten Source Code}, label=lst:bsplCodeTranslator]
// de/fh/translator/visitor/TranslateVisitor, Zeile 154 - 158
@Override
public Object visit(ASTWHILE node, Object data) {
	String ph = "while ({0}) {1}";
	return MessageFormat.format(ph, visit((SimpleNode) node.jjtGetChild(0), null), visit((SimpleNode) node.jjtGetChild(1), null), LINE_SEPARATOR);
}
\end{lstlisting}

\noindent
Als Beispiel einer Übersetzung lässt sich Listing \ref{lst:bsplCodeTranslator} heranführen. Hier wird der AST Typ \textit{WHILE} anhand von Java Regeln befüllt und übersetzt. Alle übersetzten Knoten werden zu einem einzelnen String zusammengefasst, was in dem Java Source Code resultiert. Hiermit erhält der Mustercode in Listing \ref{lst:bsplCode} folgenden Java Source Code:
\begin{lstlisting}[caption={Ausschnitt des generierten Java Codes vom Source Code in Listing \ref{lst:bsplCode}}, label=lst:bsplCodeTranslatorFinal]
// GENERATED CODE
void main () {
	Path p = new Path("D:\\Arbeit\\testing\\test2");
	Set<Integer> setA = new Set<>(0, 1, 2);
	int x = 5;
	int y ;
	int z = y = x++ + x / 2;
}
\end{lstlisting}

\noindent
Der in Listing \ref{lst:bsplCodeTranslatorFinal} generierte Java Source Code wird in einer Wrapperklasse eingefügt, wobei Hilfsklassen wie \textit{Set<T>, Map<TA, TB>, System, Path, Files} mit geforderten Methoden der Aufgabenstellung vorliegen. Die gezeigte Methode \textit{main} in Listing \ref{lst:bsplCodeTranslatorFinal} wird durch die Einsprungsmethode \textit{main} der Oberklasse aufgerufen.

\newpage
\section{Anleitung zur Ausführung}
In diesem Kapitel wird beschrieben, wie das kompilierte Programm verwendet werden kann sowie wie aus dem Source Code das Programm selbst erstellt werden kann.

\paragraph{Verwendung des kompilierten Programms} \mbox{} \\
Das Programm \textit{FARECompiler.jar} akzeptiert zwei Parameter und kann wie folgt aufgerufen werden:

\noindent
\textit{java -jar FARECompiler.jar <SourceCode> [OutputPath]}

\noindent
\textit{SourceCode} gibt den Pfad zur Textdatei an, in welcher sich der Quellcode befindet.
\textit{OutputPath} gibt jeweils den Pfad zur zu erstellenden jar-Datei an.
Wird der \textit{OutputPath} nicht gesetzt, wird der generierte AST und Java Code nur auf der Konsole angezeigt.

\noindent
Sollten zwei Parameter vorliegen, wird bei erfolgreichem Kompilieren eine ausführbare jar-Datei am \textit{OutputPath} erstellt.
Diese kann dann mit folgendem Befehl gestartet werden:

\noindent
\textit{java -jar ErzeugteDatei.jar}


\paragraph{Kompilierung des Source Codes} \mbox{} \\
Um den FARE Compiler selbst zu kompilieren, muss der Source Code als Maven Projekt initialisiert werden.
Für die bloße Generierung der JavaCC und JJTree Klassen, wird folgender Maven Befehl benötigt:

\noindent
\textit{mvn generate-sources}

\noindent
Hierbei werden die durch die Grammatik1.jjt definierte JavaCC Klassen unter dem Ordner \path{target/generated-sources} angelegt.
Um das Maven Projekt jedoch in eine ausführbare jar-Datei umzuwandeln, wird folgender Befehl benötigt:

\noindent
\textit{mvn clean generate-sources package}

\noindent
Hierbei wird das Projekt kompiliert und unter \path{target} als ausführbare jar-Datei angelegt.

\newpage
\listoftables

\newpage
\addcontentsline{toc}{section}{Listings}
\lstlistoflistings

\newpage
\addcontentsline{toc}{section}{Literatur}
%\bibliography{literatur}
\printbibliography

\newpage
\pagenumbering{gobble}
%\addcontentsline{toc}{section}{Eigenständigkeitserklärungen}
\section*{Versicherung der Eigenständigkeit}
Hiermit versichere ich, dass
ich die vorliegende Arbeit selbständig angefertigt und mich keiner fremden Hilfe bedient sowie keine
anderen als die angegebenen Quellen und Hilfsmittel benutzt habe. Alle Stellen, die wörtlich oder
sinngemäß veröffentlichten oder nicht veröffentlichten Schriften und anderen Quellen entnommen sind,
habe ich als solche kenntlich gemacht. Diese Arbeit hat in gleicher oder ähnlicher Form noch keiner
Prüfungsbehörde vorgelegen.

\signature{Johannes Lang \\ \textnormal{\textit{Matr. 7217450}} \\
	Henning Müller \\ \textnormal{\textit{Matr. 7105852}} \\
	Wladislaw Jerokin \\ \textnormal{\textit{Matr. 7205290}}
	}{Dortmund, den \today}

\end{document}