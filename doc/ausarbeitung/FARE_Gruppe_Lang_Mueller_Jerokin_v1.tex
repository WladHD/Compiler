\documentclass[a4paper,11pt,numbers=noenddot]{article}

\usepackage[main=ngerman, english]{babel}
%\usepackage{natbib}
%\bibliographystyle{plainnat}
%\setcitestyle{square,aysep={},yysep={;}}
%\setcitestyle{authoryear,square,semicolon} 
%\setcitestyle{numbers,square}

\usepackage[latin1]{inputenc}
\usepackage[babel, german=quotes]{csquotes} % einfache Handhabung von quotations
\usepackage[backend=bibtex8,style=authoryear]{biblatex} %biblatex mit biber laden
\ExecuteBibliographyOptions{
	sorting=nyt, %Sortierung Autor, Titel, Jahr
	bibwarn=true, %Probleme mit den Daten, die Backend betreffen anzeigen
	isbn=false, %keine isbn anzeigen
	url=true, %keine url anzeigen
	maxcitenames=2,
	maxbibnames=99
}
\renewcommand*{\nameyeardelim}{\addcomma\space}
\addbibresource{res/literaturBibLatex.bib} %Bibliographiedateien laden

\setlength{\parindent}{1em}
\linespread{1.2}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=black,      
	urlcolor=black,
	citecolor=black,
	pdftitle={FARE Compiler} % PDFTITLE
}


\usepackage{geometry}
\usepackage{textpos} 
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}
\usepackage{graphicx}
\usepackage{float}
\usepackage{csquotes}
\usepackage{ifthen}
\usepackage{booktabs}
\usepackage{tabu}
\usepackage[inline]{enumitem}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{pifont}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{subfig}
\usepackage{ragged2e}
\usepackage{xcolor}

\newcommand\signature[2]{% Name; Department
	\noindent\begin{minipage}{6.5cm}
		\noindent\vspace{3cm}\par
		\noindent\rule{6.5cm}{1pt}\par
		\noindent\textbf{#1}\par
		\noindent#2%
\end{minipage}}

\geometry{a4paper, left=45mm, right=15mm, top=30mm, bottom=25mm, headsep=1cm, headheight=0cm}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\usepackage{fancyhdr}
\usepackage[nottoc]{tocbibind}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\fancyhf{}
\fancyhead[C]{\Roman{page}}
\pagestyle{fancy}

\fancypagestyle{fancy}{}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{black}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\newenvironment{changemargin}[2]{%
	\begin{list}{}{%
			\setlength{\topsep}{0pt}%
			\setlength{\leftmargin}{#1}%
			\setlength{\rightmargin}{#2}%
			\setlength{\listparindent}{\parindent}%
			\setlength{\itemindent}{\parindent}%
			\setlength{\parsep}{\parskip}%
		}%
		\item[]}{\end{list}}

\lstdefinelanguage{none}{
	identifierstyle=
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\footnotesize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}


\usepackage[printonlyused]{acronym}

\makeatletter
\renewcommand*\AC@acs[1]{%
	\expandafter\AC@get\csname fn@#1\endcsname\@firstoftwo{#1}}
\makeatother

%biblatex patch, working now
%\linespread{1.25}
%\makeatletter
%\def\blx@err@patch#1{}
%\makeatother

\usepackage{setspace}
\usepackage[automake]{glossaries}
\glsdisablehyper

\newglossary[nlg]{nu}{not}{ntn}{Not Used}

\newglossaryentry{Widget}
{
	type=nu,
	name=Widget,
	description={Ein Widget ist innerhalb des Dashboards ein Element, welches Informationen anzeigt und interaktiv verwendet werden kann},
	plural=Widgets,
	%nonumberlist
}

\makeglossaries

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\definecolor{accent}{rgb}{0.41, 0.6, 0.76}

\begin{document}
	\begin{titlepage}
		\begin{textblock}{6.5}(-2.5,-3)
			\begin{color}{accent}
				\rule{6.6cm}{33cm}    
			\end{color}
		\end{textblock}
		\begin{textblock}{6.5}(-2,-1)
			{\large \textsf{Ausarbeitung}}
		\end{textblock}
		
		\doublespacing
		\begin{textblock}{8.2}(3.1,1)
			{
				\noindent \LARGE 
				\textsf{\textbf{Entwicklung eines Compilers für die Sprache FARE zur Zielsprache Java \\[0.3cm]
			} }}
		\end{textblock}
		\onehalfspacing
		
		\begin{textblock}{8.2}(3.1,3.5)
			{\noindent \large
				\textsf{\textbf{Development of a compiler for the language FARE\\ to the target language Java  \\[0.3cm]
			} }}
		\end{textblock}
		
		\begin{textblock}{6}(3.1,5.5)
			\noindent
			\textsf{An der Fachhochschule Dortmund\\
				im Fachbereich Informatik\\
				Studiengang Medizinische Informatik Master\\
				im Modul Formale Sprachen und Compilerbau\\
				erstellte Ausarbeitung eines FARE-Compilers
			}
		\end{textblock}
		
		
		
		
		\begin{textblock}{6}(-2,7.5)\noindent
			\textsf{von \\Johannes Lang \\
				Matr.-Nr. 7217450 \\ [0.2cm]
				Henning Müller \\
				Matr.-Nr. 7105852 \\ [0.2cm]
				Wladislaw Jerokin \\
				Matr.-Nr. 7205290 \\ [1cm]
				Betreuung durch: \\
				Prof. Dr. Robert Rettinger \\ [1cm]
				%In enger Zusammenarbeit mit: \\
				%Dr. Georg Lodde \\ [1cm]
				Dortmund, \today
			}
		\end{textblock}
		
		%	\begin{textblock}{6.5}(-1,10.8)
			%		\noindent
			%			\textsf{An der Fachhochschule Dortmund\\
				%			im Fachbereich Informatik\\
				%			Studiengang Medizinische Informatik\\
				%			erstellte Projektarbeit fï¿½r das \\
				%			Modul Wissenschaftliches Arbeiten
				%		}
			%	\end{textblock}
		
	\end{titlepage}
	
	\onehalfspacing
	\setlength\arrayrulewidth{1.1pt}
	\newpage
	\tableofcontents
	
	\newpage
	\setcounter{page}{1}
	\fancyhf{}
	\fancyhead[C]{\thepage}
	\pagestyle{fancy}
	\fancypagestyle{fancy}{}
	
	\section{Einleitung}
	Grundlegend definiert sich ein Compiler als Programm, welches einen gegebenen Quellcode zu Maschinencode, Bytecode oder einer anderen Programmiersprache übersetzen kann \parencite[vgl.][]{RobertSheldon.2023}.
	Die Entwicklung eines solchen Compilers ist eine komplexe Aufgabe, die aus mehreren Teilgebieten besteht.
	In dieser Ausarbeitung werden folgende Teilgebiete behandelt:
	
	\begin{longtable}{|c|c|}
		\toprule{}
		Num & Name \\ \midrule  
		
		1 & Lexikalische Analyse \\
		
		2 & Syntaxanalyse  \\
		
		3 & Semantische Analyse  \\
		
		4 & Fehlerbehandlung  \\
		
		5 & Codeerzeugung  \\ \midrule
		
		\caption{Behandelte fünf Teilbereiche des Compilerbaus}
		\label{table:bereiche}
	\end{longtable}
	
	\noindent
	Die in dieser Ausarbeitung behandelte Aufgabe besteht darin, die Bereiche in Tabelle \ref{table:bereiche} für eine Scriptsprache für den Umgang mit Dateien und Pfaden zu entwickeln.
	Folgend werden die herausgearbeiteten Token, Grammatik und Semantik in jeweils eigenen Kapiteln beschrieben.
	
	\subsection{Herangehensweise}
	\label{sec:Herangehensweise}
	Der Compiler wird in Java geschrieben und benutzt die Bibliotheken JavaCC und die JavaCC-interne JJTree.
	Somit wird die Lexikalische Analyse und die Syntaxanalyse durch die definierte Grammatik durchgeführt.
	Um dies kurz auszuführen wird mit JavaCC geprüft, ob ein gegebener Quellcode zur definierten Sprache und Grammatik zugehört (Lexikalische Analyse).
	Durch erweiterte Annotation der Grammatik wird folgend der AST durch JJTree generiert (Syntaxanalyse).
	Falls keine lexikalischen Fehler vorliegen, wird der AST zur semantischen Analyse und Fehlerbehandlung übergeben, wo auf semantische Korrektheit geprüft wird.
	Parallel wird der AST zu Java Source Code übersetzt und abschließend nach Ablauf der semantischen Analyse compiliert.
	
	
	
	
	
	
	\newpage
	\section{Token}
	\label{sec:Token}
	\begin{lstlisting}[caption={Definierte JavaCC Token}, label=lst:token]
// de/fh/javacc/Grammar1.jjt, Zeile 20 - 78
TOKEN : {
	// TYPES
	<TYPE_SPECIFIERS: "Map" | "int" | "char" | "String" | "boolean" | "Files" | "Path" | "Set" > |
	<TYPE_SPECIFIERS_VOID: "void"> |
	
	// SEPARATORS
	<BRACKET_SQUARE_LEFT: "[">          | // PRIO 15
	<BRACKET_SQUARE_RIGHT: "]">         | // PRIO 15
	<BRACKET_ROUND_LEFT: "(">           | // PRIO 15
	<BRACKET_ROUND_RIGHT: ")">          | // PRIO 15
	<BRACKET_CURLY_LEFT: "{">           |
	<BRACKET_CURLY_RIGHT: "}">          |
	<DOT: ".">                          | // PRIO 15
	<PATH_SLASH_SEPARATOR: "\\">        | // AND OP_MUL
	<SEMICOLON: ";">                    |
	<COLON: ":">                        |
	<COMMA: ",">                        |
	
	// OPERATION
	<OP_ASSIGNMENT: "="| "+=" |"-=" |"*="| "/=" | "%=">     | // PRIO 1
	<OP_LOGICAL_OR: "||">               | // PRIO 3
	<OP_LOGICAL_AND: "&&">              | // PRIO 4
	<OP_BITWISE_EXCLUSIVE_OR: "^">      | // PRIO 6
	<OP_RELATIONAL_EQUALS: "==" | "!="> | // PRIO 8
	<OP_LESS_THAN: "<">                 | // PRIO 9
	<OP_GREATER_THAN: ">">              | // PRIO 9
	<OP_RELATIONAL_COMPARE: "<=" | ">=">    | // PRIO 9
	<OP_SUM: "+" | "-">                 | // PRIO 11
	<OP_DIV: "/">                       | // PRIO 12
	<OP_MUL: "*" | "%">           | // PRIO 12
	<OP_INCREMENT: "++" | "--">         | // PRIO 13 (pre) AND 14 (post)
	<OP_PRE: "!">                       | // PRIO 13
	// PRIO 15 Round Brackets, Array Subscript, Member Selection
	
	// STATEMENTS
	<ST_IF: "if">           |
	<ST_ELSE: "else">       |
	<ST_WHILE: "while">     |
	<ST_FOR: "for">         |
	<ST_RETURN: "return">   |
	
	// LITERAL
	<LITERAL_BOOLEAN: "true" | "false">             |
	<LITERAL_IDENTIFIER: ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0" - "9"])*> |
	<LITERAL_STRING: "\""(~["\"","\n"])*"\"">       |
	<LITERAL_CHAR: "'" (~["'","\n"]) "'">           |
	<LITERAL_INTEGER: (["0"-"9"])+>                 |
	<LITERAL_PATH: (<DOT> | ".." | (["A"-"Z"] <COLON>))? ((<PATH_SLASH_SEPARATOR> | <OP_DIV>) | (((<PATH_SLASH_SEPARATOR> | <OP_DIV>) (["A"-"Z", ".", "a"-"z", "_", "0" - "9"])+ ((["A"-"Z", ".", "a"-"z", " ", "_", "0" - "9"])* (["A"-"Z", ".", "a"-"z", "_", "0" - "9"])+))+) (<PATH_SLASH_SEPARATOR> | <OP_DIV>)?) >
}

SKIP : {
	" "                     |
	"\t"                    |
	"\n"                    |
	"\r"                    |
	<COMMENT_SINGLE_LINE: "//" (~["\n"])*>     |
	<COMMENT_MULTI_LINE: "/*" (~["*"] | "*" ~["/"] )* "*/">
}
	\end{lstlisting}
	
	\noindent
	Alle definierten Token sind in Listing \ref{lst:token} aufgelistet. Wie an den Kommentaren in Zeilen 3, 7, 20, 36, und 43 erkannt werden kann, liegen 5 verschiedene Kategorien der Token vor.
	Die unterstützten Datentypen werden zuerst genannt (vgl. Listing \ref{lst:token}, Z. 4f).
	Folgend werden vielseitige Zeichen definiert, die zur Trennung von Befehlen oder auch für Operationen wie Memberselektion gebraucht werden (vgl. Listing \ref{lst:token}, Z. 8 - 18).
	Die dritte Kategorie beschreibt unäre sowie binäre Operatoren (vgl. Listing \ref{lst:token}, Z. 21 - 33).
	Die Kategorie der Statements beschreibt Schlüsselwörter für Verzweigungen, Schleifen und die Rückgabe (vgl. Listing \ref{lst:token}, Z. 37 - 41).
	
	Die letzte Kategorie der Literalen beschreibt die atomaren Werte, die vom Benutzer eingegeben werden. Unter diese fallen die Werte eines Booleans, Variablenidentifiers, Strings, Chars, Zahlen (als Integer) sowie des Paths.
	Bis auf den Path können die Ausprägungen mit Java Werten verglichen werden.
	Der Path ist eine Sonderform der Sprache FARE und beschreibt die Ausprägung eines Pfads. Dieser muss mit \textit{., .., /, $\backslash$, <LAUFWERK>:/, <LAUFWERK>:$\backslash$} beginnen. Darauf kann der Name des Verzeichnisses oder einer Datei folgen. Nach einem Separator (\textit{/, $\backslash$}) kann der Name beliebig viel wiederholt werden. Ein Name kann aus Buchstaben, Zahlen, Punkten und Leerzeichen bestehen, wobei am Anfang und am Ende eines Namens Leerzeichen verboten sind. Sonderzeichen sind nicht gestattet.
	(vgl. Listing \ref{lst:token}, Z. 44 - 49)
	
	Neben den Token die eingelesen werden, gibt es Regeln, anhand deren Zeichen ignoriert werden. Zu diesen Zählen Leerzeichen, Umbrüche, Tabulatoren sowie ein- und mehrzeilige Kommentare.
	Einzeilige Kommentare werden mit \textit{//} eingeleitet und gehen bis zum Zeilenumbruch.
	Mehrzeilige Kommentare werden mit \textit{/*} eingeleitet und enden mit \textit{*/}.
	(vgl. Listing \ref{lst:token}, Z. 53 - 58)
	 
	
	\section{Grammatik}
	\label{sec:Grammatik}
	Wie in Kapitel \ref{sec:Herangehensweise} genannt, wird JavaCC und JJTree genutzt. Um die erweiterte Grammatik zu demonstrieren, wird im Folgenden ein Beispiel angebracht.
	
		\begin{lstlisting}[caption={Beispiel der erweiterten Grammatik für Nutzung von JavaCC und JJTree anhand der Regel atom()}, label=lst:atom]
// de/fh/javacc/Grammar1.jjt, Zeile 471 - 485
void atom() :
{
	Token t;
}
{
	(t = <LITERAL_INTEGER> {jjtThis.value = t.image;})    #LITERAL_INTEGER |
	(t = <LITERAL_BOOLEAN> {jjtThis.value = t.image;})    #LITERAL_BOOLEAN |
	(t = <LITERAL_CHAR> {jjtThis.value = t.image;})       #LITERAL_CHAR    |
	(t = <LITERAL_STRING> {jjtThis.value = t.image;})     #LITERAL_STRING  |
	(t = <LITERAL_PATH> {jjtThis.value = t.image;})       #LITERAL_PATH    |
	identifier()                                                           |
	array_container()                                                      |
	native_array_container()                                               |
	<BRACKET_ROUND_LEFT> op_prio_3() <BRACKET_ROUND_RIGHT>
}
	\end{lstlisting}
	
	\noindent
	Analog zum reinen JavaCC können Regeln für die Grammatik definiert werden (vgl. Listing \ref{lst:atom}, Z. 7 - 15).
	Die Erweiterung liegt in der Annotation für die Erstellung des AST, welche die Werte \textit{void, LITERAL\_INTEGER, LITERAL\_BOOLEAN, LITERAL\_CHAR, LITERAL\_STRING, LITERAL\_PATH} annehmen kann. Im Sachkontext wird im Normalfall keine Node im AST angelegt (vgl. Listing \ref{lst:atom}, Z. 2).
	Sollte jedoch eine Regel in den Zeilen 7 - 11 angewandt werden, so wird ein entsprechend benannter Knoten zum AST mit dem Inhalt des Tokens hinzugefügt (vgl. Listing \ref{lst:atom}, Z. 7 - 8). Nach diesem Prinzip wird für alle Regeln an sinnvollen Stellen ein Knoten zum AST hinzugefügt. Diese Kombination von JavaCC und JJTree ermöglicht die simultane Lexikalische Analyse und Syntaxanalyse, was in einem AST resultiert.
	Nach der Anführung eines Beispiels wird folgend grob die Grammatik beschrieben.
\begin{lstlisting}[caption={Wurzel des AST sowie erste Regel der Grammatik}, label=lst:rootNode]
// de/fh/javacc/Grammar1.jjt, Zeile 62 - 70
SimpleNode program() throws ParseException #PROGRAM :
{
	boolean first = true;
	SimpleNode result = null;
}{
	(class_contents() { if (first) result = jjtThis; else result.jjtAddChild(jjtThis, result.jjtGetNumChildren()); })+
	
	{ return result; }
}
\end{lstlisting}	
	
	\noindent
	Da die Ausführung der ersten Regel einen AST als Rückgabewert liefert, stellt die Regel in Listing \ref{lst:rootNode} eine Sonderform dar.
	Wie erkannt werden kann, wird in jedem Fall ein neuer Knoten mit dem Namen \textit{PROGRAM} erzeugt.
	Unter diesem Knoten können nun beliebig viele \textit{class\_contents()} und vorliegen.
	
	\noindent
	Nach diesem Muster werden die restlichen Regeln ebenfalls umgesetzt. Insgesamt können 66 verschiedene AST Knotentypen vorliegen, die im Folgenden alphabetisch aufgelistet werden.
	
	
	\begin{longtable}{|c|}
		\toprule{}
		AST Typ \\ \midrule  
		ASTARRAY\_CONTAINER \\
		ASTARRAY\_CONTAINER\_NATIVE \\
		ASTARRAY\_ELEMENT \\
		ASTBLOCK \\
		ASTLITERAL\_BOOLEAN \\
		ASTLITERAL\_CHAR \\
		ASTLITERAL\_IDENTIFIER \\
		ASTLITERAL\_INTEGER \\
		ASTLITERAL\_PATH \\
		ASTLITERAL\_STRING \\
		ASTMAP\_ELEMENT \\
		ASTMAP\_ELEMENT\_KEY \\
		ASTMAP\_ELEMENT\_VALUE \\
		ASTMETHOD\_DECLARATION \\
		ASTMETHOD\_PARAM \\
		ASTMETHOD\_PARAMETERS \\
		ASTOP\_PRIO\_1 \\
		ASTOP\_PRIO\_3 \\
		ASTOP\_PRIO\_4 \\
		ASTOP\_PRIO\_6 \\
		ASTOP\_PRIO\_8 \\
		ASTOP\_PRIO\_9 \\
		ASTOP\_PRIO\_11 \\
		ASTOP\_PRIO\_12 \\
		ASTOP\_PRIO\_13 \\
		ASTOP\_PRIO\_14 \\
		ASTOP\_PRIO\_15 \\
		ASTOPERATOR\_3 \\
		ASTOPERATOR\_4 \\
		ASTOPERATOR\_6 \\
		ASTOPERATOR\_8 \\
		ASTOPERATOR\_9 \\
		ASTOPERATOR\_11 \\
		ASTOPERATOR\_12 \\
		ASTOPERATOR\_13 \\
		ASTOPERATOR\_14 \\
		ASTOPERATOR\_15\_ARRAY\_INDEX\_CALL \\
		ASTOPERATOR\_15\_MEMBER\_SELECTOR \\
		ASTOPERATOR\_15\_METHOD\_CALL \\
		ASTOPERATOR\_15\_METHOD\_CALL\_PARAM \\
		ASTOPERATOR\_15\_METHOD\_CALL\_PARAMS \\
		ASTPROGRAM \\
		ASTSEMICOLON \\
		ASTST\_ELSE\_EXPR \\
		ASTST\_ELSE\_IF \\
		ASTST\_FOR \\
		ASTST\_FOR\_EACH\_BODY \\
		ASTST\_FOR\_EACH\_BODY\_ARR \\
		ASTST\_FOR\_EACH\_BODY\_DECL \\
		ASTST\_FOR\_EXPR \\
		ASTST\_FOR\_NORMAL\_BODY \\
		ASTST\_FOR\_NORMAL\_BODY\_COND \\
		ASTST\_FOR\_NORMAL\_BODY\_DECL \\
		ASTST\_FOR\_NORMAL\_BODY\_INC \\
		ASTST\_IF \\
		ASTST\_IF\_COND \\
		ASTST\_IF\_EXPR \\
		ASTST\_RETURN \\
		ASTST\_WHILE \\
		ASTST\_WHILE\_COND \\
		ASTST\_WHILE\_EXPR \\
		ASTTYPE \\
		ASTTYPE\_ARRAY \\
		ASTTYPE\_TYPESAFE \\
		ASTVAR\_DECLARATION  \\
		ASTVAR\_INIT \\ \midrule
		
		\caption{Alle möglichen Typen von AST Knoten}
		\label{table:alleNodes}
	\end{longtable}
	
	\newpage
	\noindent
	Um die Funktionsweise der Grammatik zu verdeutlichen, wird ein AST in Listing \ref{lst:bsplAst} aus dem Quelltext in Listing \ref{lst:bsplCode} erzeugt und verschriftlicht.
\begin{lstlisting}[caption={Beispiel eines akzeptierten Source Code}, label=lst:bsplCode]
// resources/beispiel.txt
void main() {
	Path p = D:\Arbeit\testing\test2;
	Set<int> setA = [0, 1, 2];
	
	int x = 5;
	int y;
	int z = y = x++ + x / 2;
}
\end{lstlisting}

\begin{lstlisting}[caption={Erzeugter AST eines akzeptierten Source Codes in Listing \ref{lst:bsplCode}}, label=lst:bsplAst]
// Ausgabe
PROGRAM = null
 METHOD_DECLARATION = null
  TYPE = void
  LITERAL_IDENTIFIER = main
  METHOD_PARAMETERS = null
  BLOCK = null
   VAR_DECLARATION = null
    TYPE = Path
     VAR_INIT = null
      LITERAL_IDENTIFIER = p
      OP_PRIO_1 = =
       LITERAL_PATH = D:\Arbeit\testing\test2
   SEMICOLON = null
   VAR_DECLARATION = null
    TYPE = Set
     TYPE_TYPESAFE = null
      TYPE = int
    VAR_INIT = null
     LITERAL_IDENTIFIER = setA
      OP_PRIO_1 = =
       ARRAY_CONTAINER = null
        ARRAY_ELEMENT = null
         LITERAL_INTEGER = 0
        ARRAY_ELEMENT = null
         LITERAL_INTEGER = 1
        ARRAY_ELEMENT = null
         LITERAL_INTEGER = 2
    SEMICOLON = null
    VAR_DECLARATION = null
     TYPE = int
      VAR_INIT = null
       LITERAL_IDENTIFIER = x
       OP_PRIO_1 = =
        LITERAL_INTEGER = 5
    SEMICOLON = null
    VAR_DECLARATION = null
     TYPE = int
     LITERAL_IDENTIFIER = y
    SEMICOLON = null
    VAR_DECLARATION = null
     TYPE = int
      VAR_INIT = null
       LITERAL_IDENTIFIER = z
       OP_PRIO_1 = =
        VAR_INIT = null
         LITERAL_IDENTIFIER = y
         OP_PRIO_1 = =
          OP_PRIO_11 = null
           OP_PRIO_14 = null
            LITERAL_IDENTIFIER = x
            OPERATOR_14 = ++
           OPERATOR_11 = +
           OP_PRIO_12 = null
            LITERAL_IDENTIFIER = x
            OPERATOR_12 = /
            LITERAL_INTEGER = 2
    SEMICOLON = null
\end{lstlisting}

\newpage
\section{Semantik}
Nach der Erzeugung des AST wird dieser der semantischen Prüfung übergeben.
Hierbei wird gleichzeitig auch die Fehlerbehandlung abgedeckt.
Um den Umfang der semantischen Analyse zu beschreiben, lassen sich hierfür die definierten Exceptions anbringen.

\begin{longtable}{|c|c|}
	\toprule{}
	Num & Name \\ \midrule  
	
	1 & ExpectedTypeMissmatchSemanticException \\
	2 & IllegalClassContentSemanticException \\
	3 & IllegalOperationSemanticException \\
	4 & InternClosureCastingSemanticException \\
	5 & InternClosureSemanticException \\
	6 & MainMethodWithArgsSemanticException \\
	7 & MethodDeclaredSemanticException \\
	8 & MethodNotDeclaredSemanticException \\
	9 & MethodParameterMismatchSemanticException \\
	10 & NoMainMethodSemanticException \\
	11 & NoReturnSemanticException \\
	12 & NotArrayExceptionSemanticException \\
	13 & ReturnTypeMismatchSemanticException \\
	14 & SemanticException \\
	15 & StatementExpectedSemanticException \\
	16 & UnknownSemanticException \\
	17 & UnreachableCodeSemanticException \\
	18 & VariableDeclarationNotAllowedSemanticException \\
	19 & VariableDeclaredSemanticException \\
	20 & VariableNotDeclaredSemanticException \\
	21 & VariableNotInitializedSemanticException \\
	22 & WrongArrayDefinitionSemanticException  \\ \midrule
	
	\caption{Alle für die semantische Analyse definierten Exceptions}
	\label{table:semanticCheck}
\end{longtable}

\noindent
Folgend werden in Listings Beispiele für fehlerhaften Code gezeigt, welcher in ein Exceptions in Tabelle \ref{table:semanticCheck} resultieren.
\begin{lstlisting}[caption={Fehlerhafter Code resultierend in einer ExpectedTypeMissmatchSemanticException}, label=lst:errCode]
// ExpectedTypeMissmatchSemanticException
void main() { // BSP 1
	for(;34;) {} // EXCEPTION -> Condition != Boolean
	
	Set<int> mySet = [1, 2, 3];
	for(String val : mySet) {} // String != int
	
	Set<boolean> myBoolSet = [true];
	myBoolSet = myBoolSet + mySet; // Set<int> != Set<boolean>
	int x = true; // int != boolean
}
\end{lstlisting}

\begin{lstlisting}[caption={Fehlerhafter Code resultierend in einer IllegalClassContentSemanticException}, label=lst:errCode]

\end{lstlisting}

\newpage
\section{Übersetzung}
Die Übersetzung ist der letzte Schritt in Tabelle \ref{table:bereiche} und ist dafür verantwortlich, den erhaltenen AST zu Java Source Code zu übersetzen.
Dieser wird im Anschluss compiliert und zu einer ausführbaren jar-Datei verpackt.
Der Java Source Code wird hierbei während der semantischen Analyse erzeugt, um auf die kontextabhängigen Closures zuzugreifen.
Als Beispiel einer Übersetzung lässt sich Listing \ref{lst:bsplCodeTranslatorFinal} heranführen. Hier wird Mustercode in Listing \ref{lst:bsplCode} zu folgendem Java Source Code übersetzt:
\begin{lstlisting}[caption={Ausschnitt des generierten Java Codes vom Source Code in Listing \ref{lst:bsplCode}}, label=lst:bsplCodeTranslatorFinal]
// GENERATED CODE
public void main() {
	Path p = new Path("D:\\Arbeit\\testing\\test2");
	Set<Integer> setA = new Set<Integer>().add(0).add(1).add(2);
	int x = 5;
	int y;
	int z = y = x++ / 2 + x / 2;
}
\end{lstlisting}

\noindent
Der in Listing \ref{lst:bsplCodeTranslatorFinal} generierte Java Source Code wird in einer Wrapperklasse eingefügt, wobei Hilfsklassen wie \textit{Set<T>, Map<TA, TB>, System, Path, Files} mit geforderten Methoden der Aufgabenstellung vorliegen. Die gezeigte Methode \textit{main} in Listing \ref{lst:bsplCodeTranslatorFinal} wird durch die Einsprungsmethode \textit{main} der Oberklasse aufgerufen.

\newpage
\section{Anleitung zur Ausführung}
In diesem Kapitel wird beschrieben, wie das kompilierte Programm verwendet werden kann sowie wie aus dem Source Code das Programm selbst erstellt werden kann.

\paragraph{Verwendung des kompilierten Programms} \mbox{} \\
Das Programm \textit{FARECompiler.jar} akzeptiert zwei Parameter und kann wie folgt aufgerufen werden:

\noindent
\textit{java -jar FARECompiler.jar <SourceCode> [OutputPath]}

\noindent
\textit{SourceCode} gibt den Pfad zur Textdatei an, in welcher sich der Quellcode befindet.
\textit{OutputPath} gibt jeweils den Pfad zur zu erstellenden jar-Datei an.
Wird der \textit{OutputPath} nicht gesetzt, wird der generierte AST und Java Code nur auf der Konsole angezeigt.

\noindent
Sollten zwei Parameter vorliegen, wird bei erfolgreichem Kompilieren eine ausführbare jar-Datei am \textit{OutputPath} erstellt.
Diese kann dann mit folgendem Befehl gestartet werden:

\noindent
\textit{java -jar ErzeugteDatei.jar}


\paragraph{Kompilierung des Source Codes} \mbox{} \\
Um den FARE Compiler selbst zu kompilieren, muss der Source Code als Maven Projekt initialisiert werden.
Für die bloße Generierung der JavaCC und JJTree Klassen, wird folgender Maven Befehl benötigt:

\noindent
\textit{mvn generate-sources}

\noindent
Hierbei werden die durch die Grammatik1.jjt definierte JavaCC Klassen unter dem Ordner \path{target/generated-sources} angelegt.
Um das Maven Projekt jedoch in eine ausführbare jar-Datei umzuwandeln, wird folgender Befehl benötigt:

\noindent
\textit{mvn clean generate-sources package}

\noindent
Hierbei wird das Projekt kompiliert und unter \path{target} als ausführbare jar-Datei angelegt.

\newpage
\listoftables

\newpage
\addcontentsline{toc}{section}{Listings}
\lstlistoflistings

\newpage
\addcontentsline{toc}{section}{Literatur}
%\bibliography{literatur}
\printbibliography

\newpage
\pagenumbering{gobble}
%\addcontentsline{toc}{section}{Eigenständigkeitserklärungen}
\section*{Versicherung der Eigenständigkeit}
Hiermit versichere ich, dass
ich die vorliegende Arbeit selbständig angefertigt und mich keiner fremden Hilfe bedient sowie keine
anderen als die angegebenen Quellen und Hilfsmittel benutzt habe. Alle Stellen, die wörtlich oder
sinngemäß veröffentlichten oder nicht veröffentlichten Schriften und anderen Quellen entnommen sind,
habe ich als solche kenntlich gemacht. Diese Arbeit hat in gleicher oder ähnlicher Form noch keiner
Prüfungsbehörde vorgelegen.

\signature{Johannes Lang \\ \textnormal{\textit{Matr. 7217450}} \\
	Henning Müller \\ \textnormal{\textit{Matr. 7105852}} \\
	Wladislaw Jerokin \\ \textnormal{\textit{Matr. 7205290}}
	}{Dortmund, den \today}

\end{document}